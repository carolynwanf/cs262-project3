// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chatService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chatService_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chatService_2eproto;
namespace chatservice {
class AddToPendingResponse;
struct AddToPendingResponseDefaultTypeInternal;
extern AddToPendingResponseDefaultTypeInternal _AddToPendingResponse_default_instance_;
class CandidateValue;
struct CandidateValueDefaultTypeInternal;
extern CandidateValueDefaultTypeInternal _CandidateValue_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class CommitRequest;
struct CommitRequestDefaultTypeInternal;
extern CommitRequestDefaultTypeInternal _CommitRequest_default_instance_;
class CommitResponse;
struct CommitResponseDefaultTypeInternal;
extern CommitResponseDefaultTypeInternal _CommitResponse_default_instance_;
class CreateAccountMessage;
struct CreateAccountMessageDefaultTypeInternal;
extern CreateAccountMessageDefaultTypeInternal _CreateAccountMessage_default_instance_;
class CreateAccountReply;
struct CreateAccountReplyDefaultTypeInternal;
extern CreateAccountReplyDefaultTypeInternal _CreateAccountReply_default_instance_;
class DeleteAccountMessage;
struct DeleteAccountMessageDefaultTypeInternal;
extern DeleteAccountMessageDefaultTypeInternal _DeleteAccountMessage_default_instance_;
class DeleteAccountReply;
struct DeleteAccountReplyDefaultTypeInternal;
extern DeleteAccountReplyDefaultTypeInternal _DeleteAccountReply_default_instance_;
class HeartBeatRequest;
struct HeartBeatRequestDefaultTypeInternal;
extern HeartBeatRequestDefaultTypeInternal _HeartBeatRequest_default_instance_;
class HeartBeatResponse;
struct HeartBeatResponseDefaultTypeInternal;
extern HeartBeatResponseDefaultTypeInternal _HeartBeatResponse_default_instance_;
class LeaderElectionProposal;
struct LeaderElectionProposalDefaultTypeInternal;
extern LeaderElectionProposalDefaultTypeInternal _LeaderElectionProposal_default_instance_;
class LeaderElectionProposalResponse;
struct LeaderElectionProposalResponseDefaultTypeInternal;
extern LeaderElectionProposalResponseDefaultTypeInternal _LeaderElectionProposalResponse_default_instance_;
class LeaderElectionResponse;
struct LeaderElectionResponseDefaultTypeInternal;
extern LeaderElectionResponseDefaultTypeInternal _LeaderElectionResponse_default_instance_;
class LoginMessage;
struct LoginMessageDefaultTypeInternal;
extern LoginMessageDefaultTypeInternal _LoginMessage_default_instance_;
class LoginReply;
struct LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LogoutMessage;
struct LogoutMessageDefaultTypeInternal;
extern LogoutMessageDefaultTypeInternal _LogoutMessage_default_instance_;
class LogoutReply;
struct LogoutReplyDefaultTypeInternal;
extern LogoutReplyDefaultTypeInternal _LogoutReply_default_instance_;
class MessagesSeenMessage;
struct MessagesSeenMessageDefaultTypeInternal;
extern MessagesSeenMessageDefaultTypeInternal _MessagesSeenMessage_default_instance_;
class MessagesSeenReply;
struct MessagesSeenReplyDefaultTypeInternal;
extern MessagesSeenReplyDefaultTypeInternal _MessagesSeenReply_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class PendingLogRequest;
struct PendingLogRequestDefaultTypeInternal;
extern PendingLogRequestDefaultTypeInternal _PendingLogRequest_default_instance_;
class QueryMessagesMessage;
struct QueryMessagesMessageDefaultTypeInternal;
extern QueryMessagesMessageDefaultTypeInternal _QueryMessagesMessage_default_instance_;
class QueryNotificationsMessage;
struct QueryNotificationsMessageDefaultTypeInternal;
extern QueryNotificationsMessageDefaultTypeInternal _QueryNotificationsMessage_default_instance_;
class QueryUsersMessage;
struct QueryUsersMessageDefaultTypeInternal;
extern QueryUsersMessageDefaultTypeInternal _QueryUsersMessage_default_instance_;
class RefreshRequest;
struct RefreshRequestDefaultTypeInternal;
extern RefreshRequestDefaultTypeInternal _RefreshRequest_default_instance_;
class RefreshResponse;
struct RefreshResponseDefaultTypeInternal;
extern RefreshResponseDefaultTypeInternal _RefreshResponse_default_instance_;
class SendMessageReply;
struct SendMessageReplyDefaultTypeInternal;
extern SendMessageReplyDefaultTypeInternal _SendMessageReply_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace chatservice
PROTOBUF_NAMESPACE_OPEN
template<> ::chatservice::AddToPendingResponse* Arena::CreateMaybeMessage<::chatservice::AddToPendingResponse>(Arena*);
template<> ::chatservice::CandidateValue* Arena::CreateMaybeMessage<::chatservice::CandidateValue>(Arena*);
template<> ::chatservice::ChatMessage* Arena::CreateMaybeMessage<::chatservice::ChatMessage>(Arena*);
template<> ::chatservice::CommitRequest* Arena::CreateMaybeMessage<::chatservice::CommitRequest>(Arena*);
template<> ::chatservice::CommitResponse* Arena::CreateMaybeMessage<::chatservice::CommitResponse>(Arena*);
template<> ::chatservice::CreateAccountMessage* Arena::CreateMaybeMessage<::chatservice::CreateAccountMessage>(Arena*);
template<> ::chatservice::CreateAccountReply* Arena::CreateMaybeMessage<::chatservice::CreateAccountReply>(Arena*);
template<> ::chatservice::DeleteAccountMessage* Arena::CreateMaybeMessage<::chatservice::DeleteAccountMessage>(Arena*);
template<> ::chatservice::DeleteAccountReply* Arena::CreateMaybeMessage<::chatservice::DeleteAccountReply>(Arena*);
template<> ::chatservice::HeartBeatRequest* Arena::CreateMaybeMessage<::chatservice::HeartBeatRequest>(Arena*);
template<> ::chatservice::HeartBeatResponse* Arena::CreateMaybeMessage<::chatservice::HeartBeatResponse>(Arena*);
template<> ::chatservice::LeaderElectionProposal* Arena::CreateMaybeMessage<::chatservice::LeaderElectionProposal>(Arena*);
template<> ::chatservice::LeaderElectionProposalResponse* Arena::CreateMaybeMessage<::chatservice::LeaderElectionProposalResponse>(Arena*);
template<> ::chatservice::LeaderElectionResponse* Arena::CreateMaybeMessage<::chatservice::LeaderElectionResponse>(Arena*);
template<> ::chatservice::LoginMessage* Arena::CreateMaybeMessage<::chatservice::LoginMessage>(Arena*);
template<> ::chatservice::LoginReply* Arena::CreateMaybeMessage<::chatservice::LoginReply>(Arena*);
template<> ::chatservice::LogoutMessage* Arena::CreateMaybeMessage<::chatservice::LogoutMessage>(Arena*);
template<> ::chatservice::LogoutReply* Arena::CreateMaybeMessage<::chatservice::LogoutReply>(Arena*);
template<> ::chatservice::MessagesSeenMessage* Arena::CreateMaybeMessage<::chatservice::MessagesSeenMessage>(Arena*);
template<> ::chatservice::MessagesSeenReply* Arena::CreateMaybeMessage<::chatservice::MessagesSeenReply>(Arena*);
template<> ::chatservice::Notification* Arena::CreateMaybeMessage<::chatservice::Notification>(Arena*);
template<> ::chatservice::Operation* Arena::CreateMaybeMessage<::chatservice::Operation>(Arena*);
template<> ::chatservice::PendingLogRequest* Arena::CreateMaybeMessage<::chatservice::PendingLogRequest>(Arena*);
template<> ::chatservice::QueryMessagesMessage* Arena::CreateMaybeMessage<::chatservice::QueryMessagesMessage>(Arena*);
template<> ::chatservice::QueryNotificationsMessage* Arena::CreateMaybeMessage<::chatservice::QueryNotificationsMessage>(Arena*);
template<> ::chatservice::QueryUsersMessage* Arena::CreateMaybeMessage<::chatservice::QueryUsersMessage>(Arena*);
template<> ::chatservice::RefreshRequest* Arena::CreateMaybeMessage<::chatservice::RefreshRequest>(Arena*);
template<> ::chatservice::RefreshResponse* Arena::CreateMaybeMessage<::chatservice::RefreshResponse>(Arena*);
template<> ::chatservice::SendMessageReply* Arena::CreateMaybeMessage<::chatservice::SendMessageReply>(Arena*);
template<> ::chatservice::User* Arena::CreateMaybeMessage<::chatservice::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chatservice {

// ===================================================================

class CreateAccountMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.CreateAccountMessage) */ {
 public:
  inline CreateAccountMessage() : CreateAccountMessage(nullptr) {}
  ~CreateAccountMessage() override;
  explicit PROTOBUF_CONSTEXPR CreateAccountMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountMessage(const CreateAccountMessage& from);
  CreateAccountMessage(CreateAccountMessage&& from) noexcept
    : CreateAccountMessage() {
    *this = ::std::move(from);
  }

  inline CreateAccountMessage& operator=(const CreateAccountMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountMessage& operator=(CreateAccountMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountMessage* internal_default_instance() {
    return reinterpret_cast<const CreateAccountMessage*>(
               &_CreateAccountMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateAccountMessage& a, CreateAccountMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccountMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAccountMessage& from) {
    CreateAccountMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.CreateAccountMessage";
  }
  protected:
  explicit CreateAccountMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kFromLeaderFieldNumber = 3,
    kClockValFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional bool fromLeader = 3;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // int32 clockVal = 4;
  void clear_clockval();
  int32_t clockval() const;
  void set_clockval(int32_t value);
  private:
  int32_t _internal_clockval() const;
  void _internal_set_clockval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.CreateAccountMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    bool fromleader_;
    int32_t clockval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.CreateAccountReply) */ {
 public:
  inline CreateAccountReply() : CreateAccountReply(nullptr) {}
  ~CreateAccountReply() override;
  explicit PROTOBUF_CONSTEXPR CreateAccountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountReply(const CreateAccountReply& from);
  CreateAccountReply(CreateAccountReply&& from) noexcept
    : CreateAccountReply() {
    *this = ::std::move(from);
  }

  inline CreateAccountReply& operator=(const CreateAccountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountReply& operator=(CreateAccountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountReply* internal_default_instance() {
    return reinterpret_cast<const CreateAccountReply*>(
               &_CreateAccountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateAccountReply& a, CreateAccountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAccountReply& from) {
    CreateAccountReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.CreateAccountReply";
  }
  protected:
  explicit CreateAccountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kCreateAccountSuccessFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // bool createAccountSuccess = 1;
  void clear_createaccountsuccess();
  bool createaccountsuccess() const;
  void set_createaccountsuccess(bool value);
  private:
  bool _internal_createaccountsuccess() const;
  void _internal_set_createaccountsuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.CreateAccountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    bool createaccountsuccess_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LoginMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.LoginMessage) */ {
 public:
  inline LoginMessage() : LoginMessage(nullptr) {}
  ~LoginMessage() override;
  explicit PROTOBUF_CONSTEXPR LoginMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginMessage(const LoginMessage& from);
  LoginMessage(LoginMessage&& from) noexcept
    : LoginMessage() {
    *this = ::std::move(from);
  }

  inline LoginMessage& operator=(const LoginMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginMessage& operator=(LoginMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginMessage* internal_default_instance() {
    return reinterpret_cast<const LoginMessage*>(
               &_LoginMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginMessage& a, LoginMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginMessage& from) {
    LoginMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LoginMessage";
  }
  protected:
  explicit LoginMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kFromLeaderFieldNumber = 3,
    kClockValFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional bool fromLeader = 3;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // int32 clockVal = 4;
  void clear_clockval();
  int32_t clockval() const;
  void set_clockval(int32_t value);
  private:
  int32_t _internal_clockval() const;
  void _internal_set_clockval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.LoginMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    bool fromleader_;
    int32_t clockval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LoginReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.LoginReply) */ {
 public:
  inline LoginReply() : LoginReply(nullptr) {}
  ~LoginReply() override;
  explicit PROTOBUF_CONSTEXPR LoginReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReply(const LoginReply& from);
  LoginReply(LoginReply&& from) noexcept
    : LoginReply() {
    *this = ::std::move(from);
  }

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
               &_LoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginReply& a, LoginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginReply& from) {
    LoginReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LoginReply";
  }
  protected:
  explicit LoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kLoginSuccessFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // bool loginSuccess = 1;
  void clear_loginsuccess();
  bool loginsuccess() const;
  void set_loginsuccess(bool value);
  private:
  bool _internal_loginsuccess() const;
  void _internal_set_loginsuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.LoginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    bool loginsuccess_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LogoutMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.LogoutMessage) */ {
 public:
  inline LogoutMessage() : LogoutMessage(nullptr) {}
  ~LogoutMessage() override;
  explicit PROTOBUF_CONSTEXPR LogoutMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutMessage(const LogoutMessage& from);
  LogoutMessage(LogoutMessage&& from) noexcept
    : LogoutMessage() {
    *this = ::std::move(from);
  }

  inline LogoutMessage& operator=(const LogoutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutMessage& operator=(LogoutMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutMessage* internal_default_instance() {
    return reinterpret_cast<const LogoutMessage*>(
               &_LogoutMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogoutMessage& a, LogoutMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutMessage& from) {
    LogoutMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LogoutMessage";
  }
  protected:
  explicit LogoutMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kFromLeaderFieldNumber = 2,
    kClockValFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional bool fromLeader = 2;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // int32 clockVal = 3;
  void clear_clockval();
  int32_t clockval() const;
  void set_clockval(int32_t value);
  private:
  int32_t _internal_clockval() const;
  void _internal_set_clockval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.LogoutMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    bool fromleader_;
    int32_t clockval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LogoutReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.LogoutReply) */ {
 public:
  inline LogoutReply() : LogoutReply(nullptr) {}
  ~LogoutReply() override;
  explicit PROTOBUF_CONSTEXPR LogoutReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutReply(const LogoutReply& from);
  LogoutReply(LogoutReply&& from) noexcept
    : LogoutReply() {
    *this = ::std::move(from);
  }

  inline LogoutReply& operator=(const LogoutReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutReply& operator=(LogoutReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutReply* internal_default_instance() {
    return reinterpret_cast<const LogoutReply*>(
               &_LogoutReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogoutReply& a, LogoutReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutReply& from) {
    LogoutReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LogoutReply";
  }
  protected:
  explicit LogoutReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.LogoutReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class QueryUsersMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.QueryUsersMessage) */ {
 public:
  inline QueryUsersMessage() : QueryUsersMessage(nullptr) {}
  ~QueryUsersMessage() override;
  explicit PROTOBUF_CONSTEXPR QueryUsersMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryUsersMessage(const QueryUsersMessage& from);
  QueryUsersMessage(QueryUsersMessage&& from) noexcept
    : QueryUsersMessage() {
    *this = ::std::move(from);
  }

  inline QueryUsersMessage& operator=(const QueryUsersMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryUsersMessage& operator=(QueryUsersMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryUsersMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryUsersMessage* internal_default_instance() {
    return reinterpret_cast<const QueryUsersMessage*>(
               &_QueryUsersMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QueryUsersMessage& a, QueryUsersMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryUsersMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryUsersMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryUsersMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryUsersMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryUsersMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryUsersMessage& from) {
    QueryUsersMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryUsersMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.QueryUsersMessage";
  }
  protected:
  explicit QueryUsersMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kFromLeaderFieldNumber = 2,
  };
  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional bool fromLeader = 2;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.QueryUsersMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    bool fromleader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kLeaderFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string leader = 2;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class SendMessageReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.SendMessageReply) */ {
 public:
  inline SendMessageReply() : SendMessageReply(nullptr) {}
  ~SendMessageReply() override;
  explicit PROTOBUF_CONSTEXPR SendMessageReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageReply(const SendMessageReply& from);
  SendMessageReply(SendMessageReply&& from) noexcept
    : SendMessageReply() {
    *this = ::std::move(from);
  }

  inline SendMessageReply& operator=(const SendMessageReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageReply& operator=(SendMessageReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageReply* internal_default_instance() {
    return reinterpret_cast<const SendMessageReply*>(
               &_SendMessageReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SendMessageReply& a, SendMessageReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageReply& from) {
    SendMessageReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.SendMessageReply";
  }
  protected:
  explicit SendMessageReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kMessageSentFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // bool messageSent = 1;
  void clear_messagesent();
  bool messagesent() const;
  void set_messagesent(bool value);
  private:
  bool _internal_messagesent() const;
  void _internal_set_messagesent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.SendMessageReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    bool messagesent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class QueryNotificationsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.QueryNotificationsMessage) */ {
 public:
  inline QueryNotificationsMessage() : QueryNotificationsMessage(nullptr) {}
  ~QueryNotificationsMessage() override;
  explicit PROTOBUF_CONSTEXPR QueryNotificationsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryNotificationsMessage(const QueryNotificationsMessage& from);
  QueryNotificationsMessage(QueryNotificationsMessage&& from) noexcept
    : QueryNotificationsMessage() {
    *this = ::std::move(from);
  }

  inline QueryNotificationsMessage& operator=(const QueryNotificationsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryNotificationsMessage& operator=(QueryNotificationsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryNotificationsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryNotificationsMessage* internal_default_instance() {
    return reinterpret_cast<const QueryNotificationsMessage*>(
               &_QueryNotificationsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(QueryNotificationsMessage& a, QueryNotificationsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryNotificationsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryNotificationsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryNotificationsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryNotificationsMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryNotificationsMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryNotificationsMessage& from) {
    QueryNotificationsMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryNotificationsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.QueryNotificationsMessage";
  }
  protected:
  explicit QueryNotificationsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kFromLeaderFieldNumber = 2,
    kClockValFieldNumber = 3,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // optional bool fromLeader = 2;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // int32 clockVal = 3;
  void clear_clockval();
  int32_t clockval() const;
  void set_clockval(int32_t value);
  private:
  int32_t _internal_clockval() const;
  void _internal_set_clockval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.QueryNotificationsMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    bool fromleader_;
    int32_t clockval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit PROTOBUF_CONSTEXPR Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Notification& from) {
    Notification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kLeaderFieldNumber = 3,
    kNumberOfNotificationsFieldNumber = 2,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // int32 numberOfNotifications = 2;
  void clear_numberofnotifications();
  int32_t numberofnotifications() const;
  void set_numberofnotifications(int32_t value);
  private:
  int32_t _internal_numberofnotifications() const;
  void _internal_set_numberofnotifications(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.Notification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    int32_t numberofnotifications_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class QueryMessagesMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.QueryMessagesMessage) */ {
 public:
  inline QueryMessagesMessage() : QueryMessagesMessage(nullptr) {}
  ~QueryMessagesMessage() override;
  explicit PROTOBUF_CONSTEXPR QueryMessagesMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryMessagesMessage(const QueryMessagesMessage& from);
  QueryMessagesMessage(QueryMessagesMessage&& from) noexcept
    : QueryMessagesMessage() {
    *this = ::std::move(from);
  }

  inline QueryMessagesMessage& operator=(const QueryMessagesMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryMessagesMessage& operator=(QueryMessagesMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryMessagesMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryMessagesMessage* internal_default_instance() {
    return reinterpret_cast<const QueryMessagesMessage*>(
               &_QueryMessagesMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(QueryMessagesMessage& a, QueryMessagesMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryMessagesMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryMessagesMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryMessagesMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryMessagesMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryMessagesMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryMessagesMessage& from) {
    QueryMessagesMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryMessagesMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.QueryMessagesMessage";
  }
  protected:
  explicit QueryMessagesMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUsernameFieldNumber = 1,
    kOtherUsernameFieldNumber = 2,
    kFromLeaderFieldNumber = 3,
    kClockValFieldNumber = 4,
  };
  // string clientUsername = 1;
  void clear_clientusername();
  const std::string& clientusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientusername();
  PROTOBUF_NODISCARD std::string* release_clientusername();
  void set_allocated_clientusername(std::string* clientusername);
  private:
  const std::string& _internal_clientusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientusername(const std::string& value);
  std::string* _internal_mutable_clientusername();
  public:

  // string otherUsername = 2;
  void clear_otherusername();
  const std::string& otherusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otherusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otherusername();
  PROTOBUF_NODISCARD std::string* release_otherusername();
  void set_allocated_otherusername(std::string* otherusername);
  private:
  const std::string& _internal_otherusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otherusername(const std::string& value);
  std::string* _internal_mutable_otherusername();
  public:

  // optional bool fromLeader = 3;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // int32 clockVal = 4;
  void clear_clockval();
  int32_t clockval() const;
  void set_clockval(int32_t value);
  private:
  int32_t _internal_clockval() const;
  void _internal_set_clockval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.QueryMessagesMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otherusername_;
    bool fromleader_;
    int32_t clockval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  explicit PROTOBUF_CONSTEXPR ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMessage& from) {
    ChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderUsernameFieldNumber = 1,
    kRecipientUsernameFieldNumber = 2,
    kMsgContentFieldNumber = 3,
    kLeaderFieldNumber = 4,
    kFromLeaderFieldNumber = 5,
    kClockValFieldNumber = 6,
  };
  // string senderUsername = 1;
  void clear_senderusername();
  const std::string& senderusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senderusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senderusername();
  PROTOBUF_NODISCARD std::string* release_senderusername();
  void set_allocated_senderusername(std::string* senderusername);
  private:
  const std::string& _internal_senderusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senderusername(const std::string& value);
  std::string* _internal_mutable_senderusername();
  public:

  // string recipientUsername = 2;
  void clear_recipientusername();
  const std::string& recipientusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipientusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipientusername();
  PROTOBUF_NODISCARD std::string* release_recipientusername();
  void set_allocated_recipientusername(std::string* recipientusername);
  private:
  const std::string& _internal_recipientusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipientusername(const std::string& value);
  std::string* _internal_mutable_recipientusername();
  public:

  // string msgContent = 3;
  void clear_msgcontent();
  const std::string& msgcontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msgcontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msgcontent();
  PROTOBUF_NODISCARD std::string* release_msgcontent();
  void set_allocated_msgcontent(std::string* msgcontent);
  private:
  const std::string& _internal_msgcontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgcontent(const std::string& value);
  std::string* _internal_mutable_msgcontent();
  public:

  // optional string leader = 4;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional bool fromLeader = 5;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // int32 clockVal = 6;
  void clear_clockval();
  int32_t clockval() const;
  void set_clockval(int32_t value);
  private:
  int32_t _internal_clockval() const;
  void _internal_set_clockval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.ChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senderusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipientusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgcontent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    bool fromleader_;
    int32_t clockval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class DeleteAccountMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.DeleteAccountMessage) */ {
 public:
  inline DeleteAccountMessage() : DeleteAccountMessage(nullptr) {}
  ~DeleteAccountMessage() override;
  explicit PROTOBUF_CONSTEXPR DeleteAccountMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAccountMessage(const DeleteAccountMessage& from);
  DeleteAccountMessage(DeleteAccountMessage&& from) noexcept
    : DeleteAccountMessage() {
    *this = ::std::move(from);
  }

  inline DeleteAccountMessage& operator=(const DeleteAccountMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAccountMessage& operator=(DeleteAccountMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAccountMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAccountMessage* internal_default_instance() {
    return reinterpret_cast<const DeleteAccountMessage*>(
               &_DeleteAccountMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteAccountMessage& a, DeleteAccountMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAccountMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAccountMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAccountMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAccountMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAccountMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteAccountMessage& from) {
    DeleteAccountMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAccountMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.DeleteAccountMessage";
  }
  protected:
  explicit DeleteAccountMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kFromLeaderFieldNumber = 3,
    kClockValFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional bool fromLeader = 3;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // int32 clockVal = 4;
  void clear_clockval();
  int32_t clockval() const;
  void set_clockval(int32_t value);
  private:
  int32_t _internal_clockval() const;
  void _internal_set_clockval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.DeleteAccountMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    bool fromleader_;
    int32_t clockval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class DeleteAccountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.DeleteAccountReply) */ {
 public:
  inline DeleteAccountReply() : DeleteAccountReply(nullptr) {}
  ~DeleteAccountReply() override;
  explicit PROTOBUF_CONSTEXPR DeleteAccountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAccountReply(const DeleteAccountReply& from);
  DeleteAccountReply(DeleteAccountReply&& from) noexcept
    : DeleteAccountReply() {
    *this = ::std::move(from);
  }

  inline DeleteAccountReply& operator=(const DeleteAccountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAccountReply& operator=(DeleteAccountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAccountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAccountReply* internal_default_instance() {
    return reinterpret_cast<const DeleteAccountReply*>(
               &_DeleteAccountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeleteAccountReply& a, DeleteAccountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAccountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAccountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAccountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAccountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAccountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteAccountReply& from) {
    DeleteAccountReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAccountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.DeleteAccountReply";
  }
  protected:
  explicit DeleteAccountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kDeletedAccountFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // bool deletedAccount = 1;
  void clear_deletedaccount();
  bool deletedaccount() const;
  void set_deletedaccount(bool value);
  private:
  bool _internal_deletedaccount() const;
  void _internal_set_deletedaccount(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.DeleteAccountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    bool deletedaccount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class MessagesSeenMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.MessagesSeenMessage) */ {
 public:
  inline MessagesSeenMessage() : MessagesSeenMessage(nullptr) {}
  ~MessagesSeenMessage() override;
  explicit PROTOBUF_CONSTEXPR MessagesSeenMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessagesSeenMessage(const MessagesSeenMessage& from);
  MessagesSeenMessage(MessagesSeenMessage&& from) noexcept
    : MessagesSeenMessage() {
    *this = ::std::move(from);
  }

  inline MessagesSeenMessage& operator=(const MessagesSeenMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagesSeenMessage& operator=(MessagesSeenMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessagesSeenMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessagesSeenMessage* internal_default_instance() {
    return reinterpret_cast<const MessagesSeenMessage*>(
               &_MessagesSeenMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MessagesSeenMessage& a, MessagesSeenMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagesSeenMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagesSeenMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessagesSeenMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessagesSeenMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessagesSeenMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessagesSeenMessage& from) {
    MessagesSeenMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagesSeenMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.MessagesSeenMessage";
  }
  protected:
  explicit MessagesSeenMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUsernameFieldNumber = 1,
    kOtherUsernameFieldNumber = 2,
    kMessagesSeenFieldNumber = 3,
    kFromLeaderFieldNumber = 4,
    kClockValFieldNumber = 5,
  };
  // string clientUsername = 1;
  void clear_clientusername();
  const std::string& clientusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientusername();
  PROTOBUF_NODISCARD std::string* release_clientusername();
  void set_allocated_clientusername(std::string* clientusername);
  private:
  const std::string& _internal_clientusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientusername(const std::string& value);
  std::string* _internal_mutable_clientusername();
  public:

  // string otherUsername = 2;
  void clear_otherusername();
  const std::string& otherusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otherusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otherusername();
  PROTOBUF_NODISCARD std::string* release_otherusername();
  void set_allocated_otherusername(std::string* otherusername);
  private:
  const std::string& _internal_otherusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otherusername(const std::string& value);
  std::string* _internal_mutable_otherusername();
  public:

  // int32 messagesSeen = 3;
  void clear_messagesseen();
  int32_t messagesseen() const;
  void set_messagesseen(int32_t value);
  private:
  int32_t _internal_messagesseen() const;
  void _internal_set_messagesseen(int32_t value);
  public:

  // optional bool fromLeader = 4;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // int32 clockVal = 5;
  void clear_clockval();
  int32_t clockval() const;
  void set_clockval(int32_t value);
  private:
  int32_t _internal_clockval() const;
  void _internal_set_clockval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.MessagesSeenMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otherusername_;
    int32_t messagesseen_;
    bool fromleader_;
    int32_t clockval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class MessagesSeenReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.MessagesSeenReply) */ {
 public:
  inline MessagesSeenReply() : MessagesSeenReply(nullptr) {}
  ~MessagesSeenReply() override;
  explicit PROTOBUF_CONSTEXPR MessagesSeenReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessagesSeenReply(const MessagesSeenReply& from);
  MessagesSeenReply(MessagesSeenReply&& from) noexcept
    : MessagesSeenReply() {
    *this = ::std::move(from);
  }

  inline MessagesSeenReply& operator=(const MessagesSeenReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagesSeenReply& operator=(MessagesSeenReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessagesSeenReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessagesSeenReply* internal_default_instance() {
    return reinterpret_cast<const MessagesSeenReply*>(
               &_MessagesSeenReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MessagesSeenReply& a, MessagesSeenReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagesSeenReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagesSeenReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessagesSeenReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessagesSeenReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessagesSeenReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessagesSeenReply& from) {
    MessagesSeenReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagesSeenReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.MessagesSeenReply";
  }
  protected:
  explicit MessagesSeenReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderFieldNumber = 1,
  };
  // optional string leader = 1;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.MessagesSeenReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class RefreshRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.RefreshRequest) */ {
 public:
  inline RefreshRequest() : RefreshRequest(nullptr) {}
  ~RefreshRequest() override;
  explicit PROTOBUF_CONSTEXPR RefreshRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshRequest(const RefreshRequest& from);
  RefreshRequest(RefreshRequest&& from) noexcept
    : RefreshRequest() {
    *this = ::std::move(from);
  }

  inline RefreshRequest& operator=(const RefreshRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshRequest& operator=(RefreshRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshRequest*>(
               &_RefreshRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RefreshRequest& a, RefreshRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshRequest& from) {
    RefreshRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.RefreshRequest";
  }
  protected:
  explicit RefreshRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientusernameFieldNumber = 1,
    kFromLeaderFieldNumber = 2,
  };
  // string clientusername = 1;
  void clear_clientusername();
  const std::string& clientusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientusername();
  PROTOBUF_NODISCARD std::string* release_clientusername();
  void set_allocated_clientusername(std::string* clientusername);
  private:
  const std::string& _internal_clientusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientusername(const std::string& value);
  std::string* _internal_mutable_clientusername();
  public:

  // optional bool fromLeader = 2;
  bool has_fromleader() const;
  private:
  bool _internal_has_fromleader() const;
  public:
  void clear_fromleader();
  bool fromleader() const;
  void set_fromleader(bool value);
  private:
  bool _internal_fromleader() const;
  void _internal_set_fromleader(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.RefreshRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientusername_;
    bool fromleader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class RefreshResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.RefreshResponse) */ {
 public:
  inline RefreshResponse() : RefreshResponse(nullptr) {}
  ~RefreshResponse() override;
  explicit PROTOBUF_CONSTEXPR RefreshResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshResponse(const RefreshResponse& from);
  RefreshResponse(RefreshResponse&& from) noexcept
    : RefreshResponse() {
    *this = ::std::move(from);
  }

  inline RefreshResponse& operator=(const RefreshResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshResponse& operator=(RefreshResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshResponse*>(
               &_RefreshResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RefreshResponse& a, RefreshResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshResponse& from) {
    RefreshResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.RefreshResponse";
  }
  protected:
  explicit RefreshResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationsFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kForceLogoutFieldNumber = 1,
  };
  // repeated .chatservice.Notification notifications = 2;
  int notifications_size() const;
  private:
  int _internal_notifications_size() const;
  public:
  void clear_notifications();
  ::chatservice::Notification* mutable_notifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification >*
      mutable_notifications();
  private:
  const ::chatservice::Notification& _internal_notifications(int index) const;
  ::chatservice::Notification* _internal_add_notifications();
  public:
  const ::chatservice::Notification& notifications(int index) const;
  ::chatservice::Notification* add_notifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification >&
      notifications() const;

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // bool forceLogout = 1;
  void clear_forcelogout();
  bool forcelogout() const;
  void set_forcelogout(bool value);
  private:
  bool _internal_forcelogout() const;
  void _internal_set_forcelogout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.RefreshResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification > notifications_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    bool forcelogout_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class CommitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.CommitRequest) */ {
 public:
  inline CommitRequest() : CommitRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CommitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitRequest(const CommitRequest& from);
  CommitRequest(CommitRequest&& from) noexcept
    : CommitRequest() {
    *this = ::std::move(from);
  }

  inline CommitRequest& operator=(const CommitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitRequest& operator=(CommitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitRequest* internal_default_instance() {
    return reinterpret_cast<const CommitRequest*>(
               &_CommitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CommitRequest& a, CommitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommitRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommitRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.CommitRequest";
  }
  protected:
  explicit CommitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.CommitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class CommitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.CommitResponse) */ {
 public:
  inline CommitResponse() : CommitResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CommitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitResponse(const CommitResponse& from);
  CommitResponse(CommitResponse&& from) noexcept
    : CommitResponse() {
    *this = ::std::move(from);
  }

  inline CommitResponse& operator=(const CommitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitResponse& operator=(CommitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitResponse* internal_default_instance() {
    return reinterpret_cast<const CommitResponse*>(
               &_CommitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CommitResponse& a, CommitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.CommitResponse";
  }
  protected:
  explicit CommitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.CommitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.HeartBeatRequest) */ {
 public:
  inline HeartBeatRequest() : HeartBeatRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatRequest(const HeartBeatRequest& from);
  HeartBeatRequest(HeartBeatRequest&& from) noexcept
    : HeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatRequest& operator=(HeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartBeatRequest*>(
               &_HeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(HeartBeatRequest& a, HeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeartBeatRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeartBeatRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.HeartBeatRequest";
  }
  protected:
  explicit HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.HeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.HeartBeatResponse) */ {
 public:
  inline HeartBeatResponse() : HeartBeatResponse(nullptr) {}
  ~HeartBeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatResponse(const HeartBeatResponse& from);
  HeartBeatResponse(HeartBeatResponse&& from) noexcept
    : HeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatResponse& operator=(HeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartBeatResponse*>(
               &_HeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(HeartBeatResponse& a, HeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeatResponse& from) {
    HeartBeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.HeartBeatResponse";
  }
  protected:
  explicit HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsLeaderFieldNumber = 1,
  };
  // bool isLeader = 1;
  void clear_isleader();
  bool isleader() const;
  void set_isleader(bool value);
  private:
  bool _internal_isleader() const;
  void _internal_set_isleader(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.HeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isleader_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LeaderElectionProposal final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.LeaderElectionProposal) */ {
 public:
  inline LeaderElectionProposal() : LeaderElectionProposal(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LeaderElectionProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaderElectionProposal(const LeaderElectionProposal& from);
  LeaderElectionProposal(LeaderElectionProposal&& from) noexcept
    : LeaderElectionProposal() {
    *this = ::std::move(from);
  }

  inline LeaderElectionProposal& operator=(const LeaderElectionProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaderElectionProposal& operator=(LeaderElectionProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaderElectionProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaderElectionProposal* internal_default_instance() {
    return reinterpret_cast<const LeaderElectionProposal*>(
               &_LeaderElectionProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LeaderElectionProposal& a, LeaderElectionProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaderElectionProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaderElectionProposal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaderElectionProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaderElectionProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LeaderElectionProposal& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LeaderElectionProposal& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LeaderElectionProposal";
  }
  protected:
  explicit LeaderElectionProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.LeaderElectionProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LeaderElectionProposalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.LeaderElectionProposalResponse) */ {
 public:
  inline LeaderElectionProposalResponse() : LeaderElectionProposalResponse(nullptr) {}
  ~LeaderElectionProposalResponse() override;
  explicit PROTOBUF_CONSTEXPR LeaderElectionProposalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaderElectionProposalResponse(const LeaderElectionProposalResponse& from);
  LeaderElectionProposalResponse(LeaderElectionProposalResponse&& from) noexcept
    : LeaderElectionProposalResponse() {
    *this = ::std::move(from);
  }

  inline LeaderElectionProposalResponse& operator=(const LeaderElectionProposalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaderElectionProposalResponse& operator=(LeaderElectionProposalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaderElectionProposalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaderElectionProposalResponse* internal_default_instance() {
    return reinterpret_cast<const LeaderElectionProposalResponse*>(
               &_LeaderElectionProposalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LeaderElectionProposalResponse& a, LeaderElectionProposalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaderElectionProposalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaderElectionProposalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaderElectionProposalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaderElectionProposalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaderElectionProposalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaderElectionProposalResponse& from) {
    LeaderElectionProposalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaderElectionProposalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LeaderElectionProposalResponse";
  }
  protected:
  explicit LeaderElectionProposalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderFieldNumber = 2,
    kAcceptFieldNumber = 1,
  };
  // string leader = 2;
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // bool accept = 1;
  void clear_accept();
  bool accept() const;
  void set_accept(bool value);
  private:
  bool _internal_accept() const;
  void _internal_set_accept(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.LeaderElectionProposalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    bool accept_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class CandidateValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.CandidateValue) */ {
 public:
  inline CandidateValue() : CandidateValue(nullptr) {}
  ~CandidateValue() override;
  explicit PROTOBUF_CONSTEXPR CandidateValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CandidateValue(const CandidateValue& from);
  CandidateValue(CandidateValue&& from) noexcept
    : CandidateValue() {
    *this = ::std::move(from);
  }

  inline CandidateValue& operator=(const CandidateValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline CandidateValue& operator=(CandidateValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CandidateValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const CandidateValue* internal_default_instance() {
    return reinterpret_cast<const CandidateValue*>(
               &_CandidateValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CandidateValue& a, CandidateValue& b) {
    a.Swap(&b);
  }
  inline void Swap(CandidateValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CandidateValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CandidateValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CandidateValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CandidateValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CandidateValue& from) {
    CandidateValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CandidateValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.CandidateValue";
  }
  protected:
  explicit CandidateValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kNumberFieldNumber = 1,
  };
  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int32 number = 1;
  void clear_number();
  int32_t number() const;
  void set_number(int32_t value);
  private:
  int32_t _internal_number() const;
  void _internal_set_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.CandidateValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LeaderElectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.LeaderElectionResponse) */ {
 public:
  inline LeaderElectionResponse() : LeaderElectionResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LeaderElectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaderElectionResponse(const LeaderElectionResponse& from);
  LeaderElectionResponse(LeaderElectionResponse&& from) noexcept
    : LeaderElectionResponse() {
    *this = ::std::move(from);
  }

  inline LeaderElectionResponse& operator=(const LeaderElectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaderElectionResponse& operator=(LeaderElectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaderElectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaderElectionResponse* internal_default_instance() {
    return reinterpret_cast<const LeaderElectionResponse*>(
               &_LeaderElectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LeaderElectionResponse& a, LeaderElectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaderElectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaderElectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaderElectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaderElectionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LeaderElectionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LeaderElectionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LeaderElectionResponse";
  }
  protected:
  explicit LeaderElectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.LeaderElectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit PROTOBUF_CONSTEXPR Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kUsername1FieldNumber = 2,
    kUsername2FieldNumber = 3,
    kPasswordFieldNumber = 4,
    kMessageContentFieldNumber = 5,
    kMessagesseenFieldNumber = 6,
    kLeaderFieldNumber = 7,
    kClockValFieldNumber = 8,
  };
  // string message_type = 1;
  void clear_message_type();
  const std::string& message_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_type();
  PROTOBUF_NODISCARD std::string* release_message_type();
  void set_allocated_message_type(std::string* message_type);
  private:
  const std::string& _internal_message_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_type(const std::string& value);
  std::string* _internal_mutable_message_type();
  public:

  // string username1 = 2;
  void clear_username1();
  const std::string& username1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username1();
  PROTOBUF_NODISCARD std::string* release_username1();
  void set_allocated_username1(std::string* username1);
  private:
  const std::string& _internal_username1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username1(const std::string& value);
  std::string* _internal_mutable_username1();
  public:

  // string username2 = 3;
  void clear_username2();
  const std::string& username2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username2();
  PROTOBUF_NODISCARD std::string* release_username2();
  void set_allocated_username2(std::string* username2);
  private:
  const std::string& _internal_username2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username2(const std::string& value);
  std::string* _internal_mutable_username2();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string message_content = 5;
  void clear_message_content();
  const std::string& message_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_content();
  PROTOBUF_NODISCARD std::string* release_message_content();
  void set_allocated_message_content(std::string* message_content);
  private:
  const std::string& _internal_message_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_content(const std::string& value);
  std::string* _internal_mutable_message_content();
  public:

  // string messagesseen = 6;
  void clear_messagesseen();
  const std::string& messagesseen() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_messagesseen(ArgT0&& arg0, ArgT... args);
  std::string* mutable_messagesseen();
  PROTOBUF_NODISCARD std::string* release_messagesseen();
  void set_allocated_messagesseen(std::string* messagesseen);
  private:
  const std::string& _internal_messagesseen() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messagesseen(const std::string& value);
  std::string* _internal_mutable_messagesseen();
  public:

  // string leader = 7;
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // string clockVal = 8;
  void clear_clockval();
  const std::string& clockval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clockval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clockval();
  PROTOBUF_NODISCARD std::string* release_clockval();
  void set_allocated_clockval(std::string* clockval);
  private:
  const std::string& _internal_clockval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clockval(const std::string& value);
  std::string* _internal_mutable_clockval();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messagesseen_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clockval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class AddToPendingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.AddToPendingResponse) */ {
 public:
  inline AddToPendingResponse() : AddToPendingResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddToPendingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddToPendingResponse(const AddToPendingResponse& from);
  AddToPendingResponse(AddToPendingResponse&& from) noexcept
    : AddToPendingResponse() {
    *this = ::std::move(from);
  }

  inline AddToPendingResponse& operator=(const AddToPendingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddToPendingResponse& operator=(AddToPendingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddToPendingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddToPendingResponse* internal_default_instance() {
    return reinterpret_cast<const AddToPendingResponse*>(
               &_AddToPendingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AddToPendingResponse& a, AddToPendingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddToPendingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddToPendingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddToPendingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddToPendingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddToPendingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddToPendingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.AddToPendingResponse";
  }
  protected:
  explicit AddToPendingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.AddToPendingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class PendingLogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.PendingLogRequest) */ {
 public:
  inline PendingLogRequest() : PendingLogRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PendingLogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PendingLogRequest(const PendingLogRequest& from);
  PendingLogRequest(PendingLogRequest&& from) noexcept
    : PendingLogRequest() {
    *this = ::std::move(from);
  }

  inline PendingLogRequest& operator=(const PendingLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PendingLogRequest& operator=(PendingLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PendingLogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PendingLogRequest* internal_default_instance() {
    return reinterpret_cast<const PendingLogRequest*>(
               &_PendingLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PendingLogRequest& a, PendingLogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PendingLogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PendingLogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PendingLogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PendingLogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PendingLogRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PendingLogRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.PendingLogRequest";
  }
  protected:
  explicit PendingLogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.PendingLogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateAccountMessage

// string username = 1;
inline void CreateAccountMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& CreateAccountMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountMessage.username)
}
inline std::string* CreateAccountMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.CreateAccountMessage.username)
  return _s;
}
inline const std::string& CreateAccountMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void CreateAccountMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.CreateAccountMessage.username)
  return _impl_.username_.Release();
}
inline void CreateAccountMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.CreateAccountMessage.username)
}

// string password = 2;
inline void CreateAccountMessage::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CreateAccountMessage::password() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountMessage::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountMessage.password)
}
inline std::string* CreateAccountMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatservice.CreateAccountMessage.password)
  return _s;
}
inline const std::string& CreateAccountMessage::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CreateAccountMessage::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::release_password() {
  // @@protoc_insertion_point(field_release:chatservice.CreateAccountMessage.password)
  return _impl_.password_.Release();
}
inline void CreateAccountMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.CreateAccountMessage.password)
}

// optional bool fromLeader = 3;
inline bool CreateAccountMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateAccountMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void CreateAccountMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CreateAccountMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool CreateAccountMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountMessage.fromLeader)
  return _internal_fromleader();
}
inline void CreateAccountMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromleader_ = value;
}
inline void CreateAccountMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountMessage.fromLeader)
}

// int32 clockVal = 4;
inline void CreateAccountMessage::clear_clockval() {
  _impl_.clockval_ = 0;
}
inline int32_t CreateAccountMessage::_internal_clockval() const {
  return _impl_.clockval_;
}
inline int32_t CreateAccountMessage::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountMessage.clockVal)
  return _internal_clockval();
}
inline void CreateAccountMessage::_internal_set_clockval(int32_t value) {
  
  _impl_.clockval_ = value;
}
inline void CreateAccountMessage::set_clockval(int32_t value) {
  _internal_set_clockval(value);
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountMessage.clockVal)
}

// -------------------------------------------------------------------

// CreateAccountReply

// bool createAccountSuccess = 1;
inline void CreateAccountReply::clear_createaccountsuccess() {
  _impl_.createaccountsuccess_ = false;
}
inline bool CreateAccountReply::_internal_createaccountsuccess() const {
  return _impl_.createaccountsuccess_;
}
inline bool CreateAccountReply::createaccountsuccess() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountReply.createAccountSuccess)
  return _internal_createaccountsuccess();
}
inline void CreateAccountReply::_internal_set_createaccountsuccess(bool value) {
  
  _impl_.createaccountsuccess_ = value;
}
inline void CreateAccountReply::set_createaccountsuccess(bool value) {
  _internal_set_createaccountsuccess(value);
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountReply.createAccountSuccess)
}

// optional string errorMsg = 2;
inline bool CreateAccountReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateAccountReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void CreateAccountReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateAccountReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountReply.errorMsg)
}
inline std::string* CreateAccountReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.CreateAccountReply.errorMsg)
  return _s;
}
inline const std::string& CreateAccountReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void CreateAccountReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.CreateAccountReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateAccountReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.CreateAccountReply.errorMsg)
}

// optional string leader = 3;
inline bool CreateAccountReply::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateAccountReply::has_leader() const {
  return _internal_has_leader();
}
inline void CreateAccountReply::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CreateAccountReply::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountReply.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountReply::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountReply.leader)
}
inline std::string* CreateAccountReply::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.CreateAccountReply.leader)
  return _s;
}
inline const std::string& CreateAccountReply::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void CreateAccountReply::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountReply::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountReply::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.CreateAccountReply.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateAccountReply::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.CreateAccountReply.leader)
}

// -------------------------------------------------------------------

// LoginMessage

// string username = 1;
inline void LoginMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LoginMessage.username)
}
inline std::string* LoginMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.LoginMessage.username)
  return _s;
}
inline const std::string& LoginMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.LoginMessage.username)
  return _impl_.username_.Release();
}
inline void LoginMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LoginMessage.username)
}

// string password = 2;
inline void LoginMessage::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginMessage::password() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginMessage::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LoginMessage.password)
}
inline std::string* LoginMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatservice.LoginMessage.password)
  return _s;
}
inline const std::string& LoginMessage::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginMessage::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginMessage::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginMessage::release_password() {
  // @@protoc_insertion_point(field_release:chatservice.LoginMessage.password)
  return _impl_.password_.Release();
}
inline void LoginMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LoginMessage.password)
}

// optional bool fromLeader = 3;
inline bool LoginMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void LoginMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool LoginMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool LoginMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginMessage.fromLeader)
  return _internal_fromleader();
}
inline void LoginMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromleader_ = value;
}
inline void LoginMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.LoginMessage.fromLeader)
}

// int32 clockVal = 4;
inline void LoginMessage::clear_clockval() {
  _impl_.clockval_ = 0;
}
inline int32_t LoginMessage::_internal_clockval() const {
  return _impl_.clockval_;
}
inline int32_t LoginMessage::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginMessage.clockVal)
  return _internal_clockval();
}
inline void LoginMessage::_internal_set_clockval(int32_t value) {
  
  _impl_.clockval_ = value;
}
inline void LoginMessage::set_clockval(int32_t value) {
  _internal_set_clockval(value);
  // @@protoc_insertion_point(field_set:chatservice.LoginMessage.clockVal)
}

// -------------------------------------------------------------------

// LoginReply

// bool loginSuccess = 1;
inline void LoginReply::clear_loginsuccess() {
  _impl_.loginsuccess_ = false;
}
inline bool LoginReply::_internal_loginsuccess() const {
  return _impl_.loginsuccess_;
}
inline bool LoginReply::loginsuccess() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginReply.loginSuccess)
  return _internal_loginsuccess();
}
inline void LoginReply::_internal_set_loginsuccess(bool value) {
  
  _impl_.loginsuccess_ = value;
}
inline void LoginReply::set_loginsuccess(bool value) {
  _internal_set_loginsuccess(value);
  // @@protoc_insertion_point(field_set:chatservice.LoginReply.loginSuccess)
}

// optional string errorMsg = 2;
inline bool LoginReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void LoginReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LoginReply.errorMsg)
}
inline std::string* LoginReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.LoginReply.errorMsg)
  return _s;
}
inline const std::string& LoginReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void LoginReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.LoginReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LoginReply.errorMsg)
}

// optional string leader = 3;
inline bool LoginReply::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoginReply::has_leader() const {
  return _internal_has_leader();
}
inline void LoginReply::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginReply::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginReply.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReply::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LoginReply.leader)
}
inline std::string* LoginReply::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.LoginReply.leader)
  return _s;
}
inline const std::string& LoginReply::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void LoginReply::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReply::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReply::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.LoginReply.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginReply::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LoginReply.leader)
}

// -------------------------------------------------------------------

// LogoutMessage

// string username = 1;
inline void LogoutMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LogoutMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.LogoutMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LogoutMessage.username)
}
inline std::string* LogoutMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.LogoutMessage.username)
  return _s;
}
inline const std::string& LogoutMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LogoutMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.LogoutMessage.username)
  return _impl_.username_.Release();
}
inline void LogoutMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LogoutMessage.username)
}

// optional bool fromLeader = 2;
inline bool LogoutMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogoutMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void LogoutMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool LogoutMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool LogoutMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.LogoutMessage.fromLeader)
  return _internal_fromleader();
}
inline void LogoutMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromleader_ = value;
}
inline void LogoutMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.LogoutMessage.fromLeader)
}

// int32 clockVal = 3;
inline void LogoutMessage::clear_clockval() {
  _impl_.clockval_ = 0;
}
inline int32_t LogoutMessage::_internal_clockval() const {
  return _impl_.clockval_;
}
inline int32_t LogoutMessage::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.LogoutMessage.clockVal)
  return _internal_clockval();
}
inline void LogoutMessage::_internal_set_clockval(int32_t value) {
  
  _impl_.clockval_ = value;
}
inline void LogoutMessage::set_clockval(int32_t value) {
  _internal_set_clockval(value);
  // @@protoc_insertion_point(field_set:chatservice.LogoutMessage.clockVal)
}

// -------------------------------------------------------------------

// LogoutReply

// optional string errorMsg = 2;
inline bool LogoutReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogoutReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void LogoutReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogoutReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.LogoutReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LogoutReply.errorMsg)
}
inline std::string* LogoutReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.LogoutReply.errorMsg)
  return _s;
}
inline const std::string& LogoutReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void LogoutReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.LogoutReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogoutReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LogoutReply.errorMsg)
}

// optional string leader = 3;
inline bool LogoutReply::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LogoutReply::has_leader() const {
  return _internal_has_leader();
}
inline void LogoutReply::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LogoutReply::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.LogoutReply.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutReply::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LogoutReply.leader)
}
inline std::string* LogoutReply::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.LogoutReply.leader)
  return _s;
}
inline const std::string& LogoutReply::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void LogoutReply::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutReply::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutReply::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.LogoutReply.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogoutReply::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LogoutReply.leader)
}

// -------------------------------------------------------------------

// QueryUsersMessage

// optional string username = 1;
inline bool QueryUsersMessage::_internal_has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryUsersMessage::has_username() const {
  return _internal_has_username();
}
inline void QueryUsersMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryUsersMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryUsersMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryUsersMessage::set_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.QueryUsersMessage.username)
}
inline std::string* QueryUsersMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.QueryUsersMessage.username)
  return _s;
}
inline const std::string& QueryUsersMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void QueryUsersMessage::_internal_set_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryUsersMessage::_internal_mutable_username() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryUsersMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.QueryUsersMessage.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryUsersMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.QueryUsersMessage.username)
}

// optional bool fromLeader = 2;
inline bool QueryUsersMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryUsersMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void QueryUsersMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool QueryUsersMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool QueryUsersMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryUsersMessage.fromLeader)
  return _internal_fromleader();
}
inline void QueryUsersMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fromleader_ = value;
}
inline void QueryUsersMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.QueryUsersMessage.fromLeader)
}

// -------------------------------------------------------------------

// User

// string username = 1;
inline void User::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& User::username() const {
  // @@protoc_insertion_point(field_get:chatservice.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.User.username)
}
inline std::string* User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  return _impl_.username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.User.username)
  return _impl_.username_.Release();
}
inline void User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.User.username)
}

// optional string leader = 2;
inline bool User::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool User::has_leader() const {
  return _internal_has_leader();
}
inline void User::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& User::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.User.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.User.leader)
}
inline std::string* User::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.User.leader)
  return _s;
}
inline const std::string& User::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void User::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.User.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.User.leader)
}

// -------------------------------------------------------------------

// SendMessageReply

// bool messageSent = 1;
inline void SendMessageReply::clear_messagesent() {
  _impl_.messagesent_ = false;
}
inline bool SendMessageReply::_internal_messagesent() const {
  return _impl_.messagesent_;
}
inline bool SendMessageReply::messagesent() const {
  // @@protoc_insertion_point(field_get:chatservice.SendMessageReply.messageSent)
  return _internal_messagesent();
}
inline void SendMessageReply::_internal_set_messagesent(bool value) {
  
  _impl_.messagesent_ = value;
}
inline void SendMessageReply::set_messagesent(bool value) {
  _internal_set_messagesent(value);
  // @@protoc_insertion_point(field_set:chatservice.SendMessageReply.messageSent)
}

// optional string errorMsg = 2;
inline bool SendMessageReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendMessageReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void SendMessageReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendMessageReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.SendMessageReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.SendMessageReply.errorMsg)
}
inline std::string* SendMessageReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.SendMessageReply.errorMsg)
  return _s;
}
inline const std::string& SendMessageReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void SendMessageReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.SendMessageReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendMessageReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.SendMessageReply.errorMsg)
}

// optional string leader = 3;
inline bool SendMessageReply::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SendMessageReply::has_leader() const {
  return _internal_has_leader();
}
inline void SendMessageReply::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SendMessageReply::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.SendMessageReply.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageReply::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.SendMessageReply.leader)
}
inline std::string* SendMessageReply::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.SendMessageReply.leader)
  return _s;
}
inline const std::string& SendMessageReply::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void SendMessageReply::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageReply::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageReply::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.SendMessageReply.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendMessageReply::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.SendMessageReply.leader)
}

// -------------------------------------------------------------------

// QueryNotificationsMessage

// string user = 1;
inline void QueryNotificationsMessage::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& QueryNotificationsMessage::user() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryNotificationsMessage.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryNotificationsMessage::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.QueryNotificationsMessage.user)
}
inline std::string* QueryNotificationsMessage::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:chatservice.QueryNotificationsMessage.user)
  return _s;
}
inline const std::string& QueryNotificationsMessage::_internal_user() const {
  return _impl_.user_.Get();
}
inline void QueryNotificationsMessage::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryNotificationsMessage::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryNotificationsMessage::release_user() {
  // @@protoc_insertion_point(field_release:chatservice.QueryNotificationsMessage.user)
  return _impl_.user_.Release();
}
inline void QueryNotificationsMessage::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.QueryNotificationsMessage.user)
}

// optional bool fromLeader = 2;
inline bool QueryNotificationsMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryNotificationsMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void QueryNotificationsMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool QueryNotificationsMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool QueryNotificationsMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryNotificationsMessage.fromLeader)
  return _internal_fromleader();
}
inline void QueryNotificationsMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromleader_ = value;
}
inline void QueryNotificationsMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.QueryNotificationsMessage.fromLeader)
}

// int32 clockVal = 3;
inline void QueryNotificationsMessage::clear_clockval() {
  _impl_.clockval_ = 0;
}
inline int32_t QueryNotificationsMessage::_internal_clockval() const {
  return _impl_.clockval_;
}
inline int32_t QueryNotificationsMessage::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryNotificationsMessage.clockVal)
  return _internal_clockval();
}
inline void QueryNotificationsMessage::_internal_set_clockval(int32_t value) {
  
  _impl_.clockval_ = value;
}
inline void QueryNotificationsMessage::set_clockval(int32_t value) {
  _internal_set_clockval(value);
  // @@protoc_insertion_point(field_set:chatservice.QueryNotificationsMessage.clockVal)
}

// -------------------------------------------------------------------

// Notification

// string user = 1;
inline void Notification::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& Notification::user() const {
  // @@protoc_insertion_point(field_get:chatservice.Notification.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Notification.user)
}
inline std::string* Notification::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:chatservice.Notification.user)
  return _s;
}
inline const std::string& Notification::_internal_user() const {
  return _impl_.user_.Get();
}
inline void Notification::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_user() {
  // @@protoc_insertion_point(field_release:chatservice.Notification.user)
  return _impl_.user_.Release();
}
inline void Notification::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Notification.user)
}

// int32 numberOfNotifications = 2;
inline void Notification::clear_numberofnotifications() {
  _impl_.numberofnotifications_ = 0;
}
inline int32_t Notification::_internal_numberofnotifications() const {
  return _impl_.numberofnotifications_;
}
inline int32_t Notification::numberofnotifications() const {
  // @@protoc_insertion_point(field_get:chatservice.Notification.numberOfNotifications)
  return _internal_numberofnotifications();
}
inline void Notification::_internal_set_numberofnotifications(int32_t value) {
  
  _impl_.numberofnotifications_ = value;
}
inline void Notification::set_numberofnotifications(int32_t value) {
  _internal_set_numberofnotifications(value);
  // @@protoc_insertion_point(field_set:chatservice.Notification.numberOfNotifications)
}

// optional string leader = 3;
inline bool Notification::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Notification::has_leader() const {
  return _internal_has_leader();
}
inline void Notification::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Notification::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.Notification.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Notification.leader)
}
inline std::string* Notification::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.Notification.leader)
  return _s;
}
inline const std::string& Notification::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void Notification::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.Notification.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Notification::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Notification.leader)
}

// -------------------------------------------------------------------

// QueryMessagesMessage

// string clientUsername = 1;
inline void QueryMessagesMessage::clear_clientusername() {
  _impl_.clientusername_.ClearToEmpty();
}
inline const std::string& QueryMessagesMessage::clientusername() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryMessagesMessage.clientUsername)
  return _internal_clientusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryMessagesMessage::set_clientusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.QueryMessagesMessage.clientUsername)
}
inline std::string* QueryMessagesMessage::mutable_clientusername() {
  std::string* _s = _internal_mutable_clientusername();
  // @@protoc_insertion_point(field_mutable:chatservice.QueryMessagesMessage.clientUsername)
  return _s;
}
inline const std::string& QueryMessagesMessage::_internal_clientusername() const {
  return _impl_.clientusername_.Get();
}
inline void QueryMessagesMessage::_internal_set_clientusername(const std::string& value) {
  
  _impl_.clientusername_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMessagesMessage::_internal_mutable_clientusername() {
  
  return _impl_.clientusername_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryMessagesMessage::release_clientusername() {
  // @@protoc_insertion_point(field_release:chatservice.QueryMessagesMessage.clientUsername)
  return _impl_.clientusername_.Release();
}
inline void QueryMessagesMessage::set_allocated_clientusername(std::string* clientusername) {
  if (clientusername != nullptr) {
    
  } else {
    
  }
  _impl_.clientusername_.SetAllocated(clientusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientusername_.IsDefault()) {
    _impl_.clientusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.QueryMessagesMessage.clientUsername)
}

// string otherUsername = 2;
inline void QueryMessagesMessage::clear_otherusername() {
  _impl_.otherusername_.ClearToEmpty();
}
inline const std::string& QueryMessagesMessage::otherusername() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryMessagesMessage.otherUsername)
  return _internal_otherusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryMessagesMessage::set_otherusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.otherusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.QueryMessagesMessage.otherUsername)
}
inline std::string* QueryMessagesMessage::mutable_otherusername() {
  std::string* _s = _internal_mutable_otherusername();
  // @@protoc_insertion_point(field_mutable:chatservice.QueryMessagesMessage.otherUsername)
  return _s;
}
inline const std::string& QueryMessagesMessage::_internal_otherusername() const {
  return _impl_.otherusername_.Get();
}
inline void QueryMessagesMessage::_internal_set_otherusername(const std::string& value) {
  
  _impl_.otherusername_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMessagesMessage::_internal_mutable_otherusername() {
  
  return _impl_.otherusername_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryMessagesMessage::release_otherusername() {
  // @@protoc_insertion_point(field_release:chatservice.QueryMessagesMessage.otherUsername)
  return _impl_.otherusername_.Release();
}
inline void QueryMessagesMessage::set_allocated_otherusername(std::string* otherusername) {
  if (otherusername != nullptr) {
    
  } else {
    
  }
  _impl_.otherusername_.SetAllocated(otherusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.otherusername_.IsDefault()) {
    _impl_.otherusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.QueryMessagesMessage.otherUsername)
}

// optional bool fromLeader = 3;
inline bool QueryMessagesMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryMessagesMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void QueryMessagesMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool QueryMessagesMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool QueryMessagesMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryMessagesMessage.fromLeader)
  return _internal_fromleader();
}
inline void QueryMessagesMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromleader_ = value;
}
inline void QueryMessagesMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.QueryMessagesMessage.fromLeader)
}

// int32 clockVal = 4;
inline void QueryMessagesMessage::clear_clockval() {
  _impl_.clockval_ = 0;
}
inline int32_t QueryMessagesMessage::_internal_clockval() const {
  return _impl_.clockval_;
}
inline int32_t QueryMessagesMessage::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryMessagesMessage.clockVal)
  return _internal_clockval();
}
inline void QueryMessagesMessage::_internal_set_clockval(int32_t value) {
  
  _impl_.clockval_ = value;
}
inline void QueryMessagesMessage::set_clockval(int32_t value) {
  _internal_set_clockval(value);
  // @@protoc_insertion_point(field_set:chatservice.QueryMessagesMessage.clockVal)
}

// -------------------------------------------------------------------

// ChatMessage

// string senderUsername = 1;
inline void ChatMessage::clear_senderusername() {
  _impl_.senderusername_.ClearToEmpty();
}
inline const std::string& ChatMessage::senderusername() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.senderUsername)
  return _internal_senderusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_senderusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.senderusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.senderUsername)
}
inline std::string* ChatMessage::mutable_senderusername() {
  std::string* _s = _internal_mutable_senderusername();
  // @@protoc_insertion_point(field_mutable:chatservice.ChatMessage.senderUsername)
  return _s;
}
inline const std::string& ChatMessage::_internal_senderusername() const {
  return _impl_.senderusername_.Get();
}
inline void ChatMessage::_internal_set_senderusername(const std::string& value) {
  
  _impl_.senderusername_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_senderusername() {
  
  return _impl_.senderusername_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_senderusername() {
  // @@protoc_insertion_point(field_release:chatservice.ChatMessage.senderUsername)
  return _impl_.senderusername_.Release();
}
inline void ChatMessage::set_allocated_senderusername(std::string* senderusername) {
  if (senderusername != nullptr) {
    
  } else {
    
  }
  _impl_.senderusername_.SetAllocated(senderusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.senderusername_.IsDefault()) {
    _impl_.senderusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.ChatMessage.senderUsername)
}

// string recipientUsername = 2;
inline void ChatMessage::clear_recipientusername() {
  _impl_.recipientusername_.ClearToEmpty();
}
inline const std::string& ChatMessage::recipientusername() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.recipientUsername)
  return _internal_recipientusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_recipientusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipientusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.recipientUsername)
}
inline std::string* ChatMessage::mutable_recipientusername() {
  std::string* _s = _internal_mutable_recipientusername();
  // @@protoc_insertion_point(field_mutable:chatservice.ChatMessage.recipientUsername)
  return _s;
}
inline const std::string& ChatMessage::_internal_recipientusername() const {
  return _impl_.recipientusername_.Get();
}
inline void ChatMessage::_internal_set_recipientusername(const std::string& value) {
  
  _impl_.recipientusername_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_recipientusername() {
  
  return _impl_.recipientusername_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_recipientusername() {
  // @@protoc_insertion_point(field_release:chatservice.ChatMessage.recipientUsername)
  return _impl_.recipientusername_.Release();
}
inline void ChatMessage::set_allocated_recipientusername(std::string* recipientusername) {
  if (recipientusername != nullptr) {
    
  } else {
    
  }
  _impl_.recipientusername_.SetAllocated(recipientusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipientusername_.IsDefault()) {
    _impl_.recipientusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.ChatMessage.recipientUsername)
}

// string msgContent = 3;
inline void ChatMessage::clear_msgcontent() {
  _impl_.msgcontent_.ClearToEmpty();
}
inline const std::string& ChatMessage::msgcontent() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.msgContent)
  return _internal_msgcontent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_msgcontent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msgcontent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.msgContent)
}
inline std::string* ChatMessage::mutable_msgcontent() {
  std::string* _s = _internal_mutable_msgcontent();
  // @@protoc_insertion_point(field_mutable:chatservice.ChatMessage.msgContent)
  return _s;
}
inline const std::string& ChatMessage::_internal_msgcontent() const {
  return _impl_.msgcontent_.Get();
}
inline void ChatMessage::_internal_set_msgcontent(const std::string& value) {
  
  _impl_.msgcontent_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_msgcontent() {
  
  return _impl_.msgcontent_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_msgcontent() {
  // @@protoc_insertion_point(field_release:chatservice.ChatMessage.msgContent)
  return _impl_.msgcontent_.Release();
}
inline void ChatMessage::set_allocated_msgcontent(std::string* msgcontent) {
  if (msgcontent != nullptr) {
    
  } else {
    
  }
  _impl_.msgcontent_.SetAllocated(msgcontent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msgcontent_.IsDefault()) {
    _impl_.msgcontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.ChatMessage.msgContent)
}

// optional string leader = 4;
inline bool ChatMessage::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatMessage::has_leader() const {
  return _internal_has_leader();
}
inline void ChatMessage::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatMessage::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.leader)
}
inline std::string* ChatMessage::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.ChatMessage.leader)
  return _s;
}
inline const std::string& ChatMessage::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void ChatMessage::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.ChatMessage.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatMessage::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.ChatMessage.leader)
}

// optional bool fromLeader = 5;
inline bool ChatMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChatMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void ChatMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ChatMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool ChatMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.fromLeader)
  return _internal_fromleader();
}
inline void ChatMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fromleader_ = value;
}
inline void ChatMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.fromLeader)
}

// int32 clockVal = 6;
inline void ChatMessage::clear_clockval() {
  _impl_.clockval_ = 0;
}
inline int32_t ChatMessage::_internal_clockval() const {
  return _impl_.clockval_;
}
inline int32_t ChatMessage::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.clockVal)
  return _internal_clockval();
}
inline void ChatMessage::_internal_set_clockval(int32_t value) {
  
  _impl_.clockval_ = value;
}
inline void ChatMessage::set_clockval(int32_t value) {
  _internal_set_clockval(value);
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.clockVal)
}

// -------------------------------------------------------------------

// DeleteAccountMessage

// string username = 1;
inline void DeleteAccountMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& DeleteAccountMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAccountMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountMessage.username)
}
inline std::string* DeleteAccountMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.DeleteAccountMessage.username)
  return _s;
}
inline const std::string& DeleteAccountMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void DeleteAccountMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAccountMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAccountMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.DeleteAccountMessage.username)
  return _impl_.username_.Release();
}
inline void DeleteAccountMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.DeleteAccountMessage.username)
}

// string password = 2;
inline void DeleteAccountMessage::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& DeleteAccountMessage::password() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAccountMessage::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountMessage.password)
}
inline std::string* DeleteAccountMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatservice.DeleteAccountMessage.password)
  return _s;
}
inline const std::string& DeleteAccountMessage::_internal_password() const {
  return _impl_.password_.Get();
}
inline void DeleteAccountMessage::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAccountMessage::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAccountMessage::release_password() {
  // @@protoc_insertion_point(field_release:chatservice.DeleteAccountMessage.password)
  return _impl_.password_.Release();
}
inline void DeleteAccountMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.DeleteAccountMessage.password)
}

// optional bool fromLeader = 3;
inline bool DeleteAccountMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteAccountMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void DeleteAccountMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeleteAccountMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool DeleteAccountMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountMessage.fromLeader)
  return _internal_fromleader();
}
inline void DeleteAccountMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromleader_ = value;
}
inline void DeleteAccountMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountMessage.fromLeader)
}

// int32 clockVal = 4;
inline void DeleteAccountMessage::clear_clockval() {
  _impl_.clockval_ = 0;
}
inline int32_t DeleteAccountMessage::_internal_clockval() const {
  return _impl_.clockval_;
}
inline int32_t DeleteAccountMessage::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountMessage.clockVal)
  return _internal_clockval();
}
inline void DeleteAccountMessage::_internal_set_clockval(int32_t value) {
  
  _impl_.clockval_ = value;
}
inline void DeleteAccountMessage::set_clockval(int32_t value) {
  _internal_set_clockval(value);
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountMessage.clockVal)
}

// -------------------------------------------------------------------

// DeleteAccountReply

// bool deletedAccount = 1;
inline void DeleteAccountReply::clear_deletedaccount() {
  _impl_.deletedaccount_ = false;
}
inline bool DeleteAccountReply::_internal_deletedaccount() const {
  return _impl_.deletedaccount_;
}
inline bool DeleteAccountReply::deletedaccount() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountReply.deletedAccount)
  return _internal_deletedaccount();
}
inline void DeleteAccountReply::_internal_set_deletedaccount(bool value) {
  
  _impl_.deletedaccount_ = value;
}
inline void DeleteAccountReply::set_deletedaccount(bool value) {
  _internal_set_deletedaccount(value);
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountReply.deletedAccount)
}

// optional string errorMsg = 2;
inline bool DeleteAccountReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteAccountReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void DeleteAccountReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeleteAccountReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAccountReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountReply.errorMsg)
}
inline std::string* DeleteAccountReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.DeleteAccountReply.errorMsg)
  return _s;
}
inline const std::string& DeleteAccountReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void DeleteAccountReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAccountReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAccountReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.DeleteAccountReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeleteAccountReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.DeleteAccountReply.errorMsg)
}

// optional string leader = 3;
inline bool DeleteAccountReply::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeleteAccountReply::has_leader() const {
  return _internal_has_leader();
}
inline void DeleteAccountReply::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeleteAccountReply::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountReply.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAccountReply::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountReply.leader)
}
inline std::string* DeleteAccountReply::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.DeleteAccountReply.leader)
  return _s;
}
inline const std::string& DeleteAccountReply::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void DeleteAccountReply::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAccountReply::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAccountReply::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.DeleteAccountReply.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeleteAccountReply::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.DeleteAccountReply.leader)
}

// -------------------------------------------------------------------

// MessagesSeenMessage

// string clientUsername = 1;
inline void MessagesSeenMessage::clear_clientusername() {
  _impl_.clientusername_.ClearToEmpty();
}
inline const std::string& MessagesSeenMessage::clientusername() const {
  // @@protoc_insertion_point(field_get:chatservice.MessagesSeenMessage.clientUsername)
  return _internal_clientusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessagesSeenMessage::set_clientusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.MessagesSeenMessage.clientUsername)
}
inline std::string* MessagesSeenMessage::mutable_clientusername() {
  std::string* _s = _internal_mutable_clientusername();
  // @@protoc_insertion_point(field_mutable:chatservice.MessagesSeenMessage.clientUsername)
  return _s;
}
inline const std::string& MessagesSeenMessage::_internal_clientusername() const {
  return _impl_.clientusername_.Get();
}
inline void MessagesSeenMessage::_internal_set_clientusername(const std::string& value) {
  
  _impl_.clientusername_.Set(value, GetArenaForAllocation());
}
inline std::string* MessagesSeenMessage::_internal_mutable_clientusername() {
  
  return _impl_.clientusername_.Mutable(GetArenaForAllocation());
}
inline std::string* MessagesSeenMessage::release_clientusername() {
  // @@protoc_insertion_point(field_release:chatservice.MessagesSeenMessage.clientUsername)
  return _impl_.clientusername_.Release();
}
inline void MessagesSeenMessage::set_allocated_clientusername(std::string* clientusername) {
  if (clientusername != nullptr) {
    
  } else {
    
  }
  _impl_.clientusername_.SetAllocated(clientusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientusername_.IsDefault()) {
    _impl_.clientusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.MessagesSeenMessage.clientUsername)
}

// string otherUsername = 2;
inline void MessagesSeenMessage::clear_otherusername() {
  _impl_.otherusername_.ClearToEmpty();
}
inline const std::string& MessagesSeenMessage::otherusername() const {
  // @@protoc_insertion_point(field_get:chatservice.MessagesSeenMessage.otherUsername)
  return _internal_otherusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessagesSeenMessage::set_otherusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.otherusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.MessagesSeenMessage.otherUsername)
}
inline std::string* MessagesSeenMessage::mutable_otherusername() {
  std::string* _s = _internal_mutable_otherusername();
  // @@protoc_insertion_point(field_mutable:chatservice.MessagesSeenMessage.otherUsername)
  return _s;
}
inline const std::string& MessagesSeenMessage::_internal_otherusername() const {
  return _impl_.otherusername_.Get();
}
inline void MessagesSeenMessage::_internal_set_otherusername(const std::string& value) {
  
  _impl_.otherusername_.Set(value, GetArenaForAllocation());
}
inline std::string* MessagesSeenMessage::_internal_mutable_otherusername() {
  
  return _impl_.otherusername_.Mutable(GetArenaForAllocation());
}
inline std::string* MessagesSeenMessage::release_otherusername() {
  // @@protoc_insertion_point(field_release:chatservice.MessagesSeenMessage.otherUsername)
  return _impl_.otherusername_.Release();
}
inline void MessagesSeenMessage::set_allocated_otherusername(std::string* otherusername) {
  if (otherusername != nullptr) {
    
  } else {
    
  }
  _impl_.otherusername_.SetAllocated(otherusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.otherusername_.IsDefault()) {
    _impl_.otherusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.MessagesSeenMessage.otherUsername)
}

// int32 messagesSeen = 3;
inline void MessagesSeenMessage::clear_messagesseen() {
  _impl_.messagesseen_ = 0;
}
inline int32_t MessagesSeenMessage::_internal_messagesseen() const {
  return _impl_.messagesseen_;
}
inline int32_t MessagesSeenMessage::messagesseen() const {
  // @@protoc_insertion_point(field_get:chatservice.MessagesSeenMessage.messagesSeen)
  return _internal_messagesseen();
}
inline void MessagesSeenMessage::_internal_set_messagesseen(int32_t value) {
  
  _impl_.messagesseen_ = value;
}
inline void MessagesSeenMessage::set_messagesseen(int32_t value) {
  _internal_set_messagesseen(value);
  // @@protoc_insertion_point(field_set:chatservice.MessagesSeenMessage.messagesSeen)
}

// optional bool fromLeader = 4;
inline bool MessagesSeenMessage::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessagesSeenMessage::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void MessagesSeenMessage::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MessagesSeenMessage::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool MessagesSeenMessage::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.MessagesSeenMessage.fromLeader)
  return _internal_fromleader();
}
inline void MessagesSeenMessage::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromleader_ = value;
}
inline void MessagesSeenMessage::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.MessagesSeenMessage.fromLeader)
}

// int32 clockVal = 5;
inline void MessagesSeenMessage::clear_clockval() {
  _impl_.clockval_ = 0;
}
inline int32_t MessagesSeenMessage::_internal_clockval() const {
  return _impl_.clockval_;
}
inline int32_t MessagesSeenMessage::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.MessagesSeenMessage.clockVal)
  return _internal_clockval();
}
inline void MessagesSeenMessage::_internal_set_clockval(int32_t value) {
  
  _impl_.clockval_ = value;
}
inline void MessagesSeenMessage::set_clockval(int32_t value) {
  _internal_set_clockval(value);
  // @@protoc_insertion_point(field_set:chatservice.MessagesSeenMessage.clockVal)
}

// -------------------------------------------------------------------

// MessagesSeenReply

// optional string leader = 1;
inline bool MessagesSeenReply::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessagesSeenReply::has_leader() const {
  return _internal_has_leader();
}
inline void MessagesSeenReply::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessagesSeenReply::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.MessagesSeenReply.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessagesSeenReply::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.MessagesSeenReply.leader)
}
inline std::string* MessagesSeenReply::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.MessagesSeenReply.leader)
  return _s;
}
inline const std::string& MessagesSeenReply::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void MessagesSeenReply::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* MessagesSeenReply::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* MessagesSeenReply::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.MessagesSeenReply.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MessagesSeenReply::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.MessagesSeenReply.leader)
}

// -------------------------------------------------------------------

// RefreshRequest

// string clientusername = 1;
inline void RefreshRequest::clear_clientusername() {
  _impl_.clientusername_.ClearToEmpty();
}
inline const std::string& RefreshRequest::clientusername() const {
  // @@protoc_insertion_point(field_get:chatservice.RefreshRequest.clientusername)
  return _internal_clientusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshRequest::set_clientusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.RefreshRequest.clientusername)
}
inline std::string* RefreshRequest::mutable_clientusername() {
  std::string* _s = _internal_mutable_clientusername();
  // @@protoc_insertion_point(field_mutable:chatservice.RefreshRequest.clientusername)
  return _s;
}
inline const std::string& RefreshRequest::_internal_clientusername() const {
  return _impl_.clientusername_.Get();
}
inline void RefreshRequest::_internal_set_clientusername(const std::string& value) {
  
  _impl_.clientusername_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshRequest::_internal_mutable_clientusername() {
  
  return _impl_.clientusername_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshRequest::release_clientusername() {
  // @@protoc_insertion_point(field_release:chatservice.RefreshRequest.clientusername)
  return _impl_.clientusername_.Release();
}
inline void RefreshRequest::set_allocated_clientusername(std::string* clientusername) {
  if (clientusername != nullptr) {
    
  } else {
    
  }
  _impl_.clientusername_.SetAllocated(clientusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientusername_.IsDefault()) {
    _impl_.clientusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.RefreshRequest.clientusername)
}

// optional bool fromLeader = 2;
inline bool RefreshRequest::_internal_has_fromleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RefreshRequest::has_fromleader() const {
  return _internal_has_fromleader();
}
inline void RefreshRequest::clear_fromleader() {
  _impl_.fromleader_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RefreshRequest::_internal_fromleader() const {
  return _impl_.fromleader_;
}
inline bool RefreshRequest::fromleader() const {
  // @@protoc_insertion_point(field_get:chatservice.RefreshRequest.fromLeader)
  return _internal_fromleader();
}
inline void RefreshRequest::_internal_set_fromleader(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fromleader_ = value;
}
inline void RefreshRequest::set_fromleader(bool value) {
  _internal_set_fromleader(value);
  // @@protoc_insertion_point(field_set:chatservice.RefreshRequest.fromLeader)
}

// -------------------------------------------------------------------

// RefreshResponse

// bool forceLogout = 1;
inline void RefreshResponse::clear_forcelogout() {
  _impl_.forcelogout_ = false;
}
inline bool RefreshResponse::_internal_forcelogout() const {
  return _impl_.forcelogout_;
}
inline bool RefreshResponse::forcelogout() const {
  // @@protoc_insertion_point(field_get:chatservice.RefreshResponse.forceLogout)
  return _internal_forcelogout();
}
inline void RefreshResponse::_internal_set_forcelogout(bool value) {
  
  _impl_.forcelogout_ = value;
}
inline void RefreshResponse::set_forcelogout(bool value) {
  _internal_set_forcelogout(value);
  // @@protoc_insertion_point(field_set:chatservice.RefreshResponse.forceLogout)
}

// repeated .chatservice.Notification notifications = 2;
inline int RefreshResponse::_internal_notifications_size() const {
  return _impl_.notifications_.size();
}
inline int RefreshResponse::notifications_size() const {
  return _internal_notifications_size();
}
inline void RefreshResponse::clear_notifications() {
  _impl_.notifications_.Clear();
}
inline ::chatservice::Notification* RefreshResponse::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:chatservice.RefreshResponse.notifications)
  return _impl_.notifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification >*
RefreshResponse::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:chatservice.RefreshResponse.notifications)
  return &_impl_.notifications_;
}
inline const ::chatservice::Notification& RefreshResponse::_internal_notifications(int index) const {
  return _impl_.notifications_.Get(index);
}
inline const ::chatservice::Notification& RefreshResponse::notifications(int index) const {
  // @@protoc_insertion_point(field_get:chatservice.RefreshResponse.notifications)
  return _internal_notifications(index);
}
inline ::chatservice::Notification* RefreshResponse::_internal_add_notifications() {
  return _impl_.notifications_.Add();
}
inline ::chatservice::Notification* RefreshResponse::add_notifications() {
  ::chatservice::Notification* _add = _internal_add_notifications();
  // @@protoc_insertion_point(field_add:chatservice.RefreshResponse.notifications)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification >&
RefreshResponse::notifications() const {
  // @@protoc_insertion_point(field_list:chatservice.RefreshResponse.notifications)
  return _impl_.notifications_;
}

// optional string leader = 3;
inline bool RefreshResponse::_internal_has_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RefreshResponse::has_leader() const {
  return _internal_has_leader();
}
inline void RefreshResponse::clear_leader() {
  _impl_.leader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RefreshResponse::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.RefreshResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.RefreshResponse.leader)
}
inline std::string* RefreshResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.RefreshResponse.leader)
  return _s;
}
inline const std::string& RefreshResponse::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void RefreshResponse::_internal_set_leader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshResponse::_internal_mutable_leader() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshResponse::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.RefreshResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.leader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RefreshResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.RefreshResponse.leader)
}

// -------------------------------------------------------------------

// CommitRequest

// -------------------------------------------------------------------

// CommitResponse

// -------------------------------------------------------------------

// HeartBeatRequest

// -------------------------------------------------------------------

// HeartBeatResponse

// bool isLeader = 1;
inline void HeartBeatResponse::clear_isleader() {
  _impl_.isleader_ = false;
}
inline bool HeartBeatResponse::_internal_isleader() const {
  return _impl_.isleader_;
}
inline bool HeartBeatResponse::isleader() const {
  // @@protoc_insertion_point(field_get:chatservice.HeartBeatResponse.isLeader)
  return _internal_isleader();
}
inline void HeartBeatResponse::_internal_set_isleader(bool value) {
  
  _impl_.isleader_ = value;
}
inline void HeartBeatResponse::set_isleader(bool value) {
  _internal_set_isleader(value);
  // @@protoc_insertion_point(field_set:chatservice.HeartBeatResponse.isLeader)
}

// -------------------------------------------------------------------

// LeaderElectionProposal

// -------------------------------------------------------------------

// LeaderElectionProposalResponse

// bool accept = 1;
inline void LeaderElectionProposalResponse::clear_accept() {
  _impl_.accept_ = false;
}
inline bool LeaderElectionProposalResponse::_internal_accept() const {
  return _impl_.accept_;
}
inline bool LeaderElectionProposalResponse::accept() const {
  // @@protoc_insertion_point(field_get:chatservice.LeaderElectionProposalResponse.accept)
  return _internal_accept();
}
inline void LeaderElectionProposalResponse::_internal_set_accept(bool value) {
  
  _impl_.accept_ = value;
}
inline void LeaderElectionProposalResponse::set_accept(bool value) {
  _internal_set_accept(value);
  // @@protoc_insertion_point(field_set:chatservice.LeaderElectionProposalResponse.accept)
}

// string leader = 2;
inline void LeaderElectionProposalResponse::clear_leader() {
  _impl_.leader_.ClearToEmpty();
}
inline const std::string& LeaderElectionProposalResponse::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.LeaderElectionProposalResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaderElectionProposalResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LeaderElectionProposalResponse.leader)
}
inline std::string* LeaderElectionProposalResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.LeaderElectionProposalResponse.leader)
  return _s;
}
inline const std::string& LeaderElectionProposalResponse::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void LeaderElectionProposalResponse::_internal_set_leader(const std::string& value) {
  
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* LeaderElectionProposalResponse::_internal_mutable_leader() {
  
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* LeaderElectionProposalResponse::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.LeaderElectionProposalResponse.leader)
  return _impl_.leader_.Release();
}
inline void LeaderElectionProposalResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    
  } else {
    
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LeaderElectionProposalResponse.leader)
}

// -------------------------------------------------------------------

// CandidateValue

// int32 number = 1;
inline void CandidateValue::clear_number() {
  _impl_.number_ = 0;
}
inline int32_t CandidateValue::_internal_number() const {
  return _impl_.number_;
}
inline int32_t CandidateValue::number() const {
  // @@protoc_insertion_point(field_get:chatservice.CandidateValue.number)
  return _internal_number();
}
inline void CandidateValue::_internal_set_number(int32_t value) {
  
  _impl_.number_ = value;
}
inline void CandidateValue::set_number(int32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:chatservice.CandidateValue.number)
}

// string address = 2;
inline void CandidateValue::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& CandidateValue::address() const {
  // @@protoc_insertion_point(field_get:chatservice.CandidateValue.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CandidateValue::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.CandidateValue.address)
}
inline std::string* CandidateValue::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:chatservice.CandidateValue.address)
  return _s;
}
inline const std::string& CandidateValue::_internal_address() const {
  return _impl_.address_.Get();
}
inline void CandidateValue::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* CandidateValue::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* CandidateValue::release_address() {
  // @@protoc_insertion_point(field_release:chatservice.CandidateValue.address)
  return _impl_.address_.Release();
}
inline void CandidateValue::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.CandidateValue.address)
}

// -------------------------------------------------------------------

// LeaderElectionResponse

// -------------------------------------------------------------------

// Operation

// string message_type = 1;
inline void Operation::clear_message_type() {
  _impl_.message_type_.ClearToEmpty();
}
inline const std::string& Operation::message_type() const {
  // @@protoc_insertion_point(field_get:chatservice.Operation.message_type)
  return _internal_message_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_message_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Operation.message_type)
}
inline std::string* Operation::mutable_message_type() {
  std::string* _s = _internal_mutable_message_type();
  // @@protoc_insertion_point(field_mutable:chatservice.Operation.message_type)
  return _s;
}
inline const std::string& Operation::_internal_message_type() const {
  return _impl_.message_type_.Get();
}
inline void Operation::_internal_set_message_type(const std::string& value) {
  
  _impl_.message_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_message_type() {
  
  return _impl_.message_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_message_type() {
  // @@protoc_insertion_point(field_release:chatservice.Operation.message_type)
  return _impl_.message_type_.Release();
}
inline void Operation::set_allocated_message_type(std::string* message_type) {
  if (message_type != nullptr) {
    
  } else {
    
  }
  _impl_.message_type_.SetAllocated(message_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_type_.IsDefault()) {
    _impl_.message_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Operation.message_type)
}

// string username1 = 2;
inline void Operation::clear_username1() {
  _impl_.username1_.ClearToEmpty();
}
inline const std::string& Operation::username1() const {
  // @@protoc_insertion_point(field_get:chatservice.Operation.username1)
  return _internal_username1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_username1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Operation.username1)
}
inline std::string* Operation::mutable_username1() {
  std::string* _s = _internal_mutable_username1();
  // @@protoc_insertion_point(field_mutable:chatservice.Operation.username1)
  return _s;
}
inline const std::string& Operation::_internal_username1() const {
  return _impl_.username1_.Get();
}
inline void Operation::_internal_set_username1(const std::string& value) {
  
  _impl_.username1_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_username1() {
  
  return _impl_.username1_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_username1() {
  // @@protoc_insertion_point(field_release:chatservice.Operation.username1)
  return _impl_.username1_.Release();
}
inline void Operation::set_allocated_username1(std::string* username1) {
  if (username1 != nullptr) {
    
  } else {
    
  }
  _impl_.username1_.SetAllocated(username1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username1_.IsDefault()) {
    _impl_.username1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Operation.username1)
}

// string username2 = 3;
inline void Operation::clear_username2() {
  _impl_.username2_.ClearToEmpty();
}
inline const std::string& Operation::username2() const {
  // @@protoc_insertion_point(field_get:chatservice.Operation.username2)
  return _internal_username2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_username2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Operation.username2)
}
inline std::string* Operation::mutable_username2() {
  std::string* _s = _internal_mutable_username2();
  // @@protoc_insertion_point(field_mutable:chatservice.Operation.username2)
  return _s;
}
inline const std::string& Operation::_internal_username2() const {
  return _impl_.username2_.Get();
}
inline void Operation::_internal_set_username2(const std::string& value) {
  
  _impl_.username2_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_username2() {
  
  return _impl_.username2_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_username2() {
  // @@protoc_insertion_point(field_release:chatservice.Operation.username2)
  return _impl_.username2_.Release();
}
inline void Operation::set_allocated_username2(std::string* username2) {
  if (username2 != nullptr) {
    
  } else {
    
  }
  _impl_.username2_.SetAllocated(username2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username2_.IsDefault()) {
    _impl_.username2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Operation.username2)
}

// string password = 4;
inline void Operation::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Operation::password() const {
  // @@protoc_insertion_point(field_get:chatservice.Operation.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Operation.password)
}
inline std::string* Operation::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatservice.Operation.password)
  return _s;
}
inline const std::string& Operation::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Operation::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_password() {
  // @@protoc_insertion_point(field_release:chatservice.Operation.password)
  return _impl_.password_.Release();
}
inline void Operation::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Operation.password)
}

// string message_content = 5;
inline void Operation::clear_message_content() {
  _impl_.message_content_.ClearToEmpty();
}
inline const std::string& Operation::message_content() const {
  // @@protoc_insertion_point(field_get:chatservice.Operation.message_content)
  return _internal_message_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_message_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Operation.message_content)
}
inline std::string* Operation::mutable_message_content() {
  std::string* _s = _internal_mutable_message_content();
  // @@protoc_insertion_point(field_mutable:chatservice.Operation.message_content)
  return _s;
}
inline const std::string& Operation::_internal_message_content() const {
  return _impl_.message_content_.Get();
}
inline void Operation::_internal_set_message_content(const std::string& value) {
  
  _impl_.message_content_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_message_content() {
  
  return _impl_.message_content_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_message_content() {
  // @@protoc_insertion_point(field_release:chatservice.Operation.message_content)
  return _impl_.message_content_.Release();
}
inline void Operation::set_allocated_message_content(std::string* message_content) {
  if (message_content != nullptr) {
    
  } else {
    
  }
  _impl_.message_content_.SetAllocated(message_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_content_.IsDefault()) {
    _impl_.message_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Operation.message_content)
}

// string messagesseen = 6;
inline void Operation::clear_messagesseen() {
  _impl_.messagesseen_.ClearToEmpty();
}
inline const std::string& Operation::messagesseen() const {
  // @@protoc_insertion_point(field_get:chatservice.Operation.messagesseen)
  return _internal_messagesseen();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_messagesseen(ArgT0&& arg0, ArgT... args) {
 
 _impl_.messagesseen_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Operation.messagesseen)
}
inline std::string* Operation::mutable_messagesseen() {
  std::string* _s = _internal_mutable_messagesseen();
  // @@protoc_insertion_point(field_mutable:chatservice.Operation.messagesseen)
  return _s;
}
inline const std::string& Operation::_internal_messagesseen() const {
  return _impl_.messagesseen_.Get();
}
inline void Operation::_internal_set_messagesseen(const std::string& value) {
  
  _impl_.messagesseen_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_messagesseen() {
  
  return _impl_.messagesseen_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_messagesseen() {
  // @@protoc_insertion_point(field_release:chatservice.Operation.messagesseen)
  return _impl_.messagesseen_.Release();
}
inline void Operation::set_allocated_messagesseen(std::string* messagesseen) {
  if (messagesseen != nullptr) {
    
  } else {
    
  }
  _impl_.messagesseen_.SetAllocated(messagesseen, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.messagesseen_.IsDefault()) {
    _impl_.messagesseen_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Operation.messagesseen)
}

// string leader = 7;
inline void Operation::clear_leader() {
  _impl_.leader_.ClearToEmpty();
}
inline const std::string& Operation::leader() const {
  // @@protoc_insertion_point(field_get:chatservice.Operation.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_leader(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Operation.leader)
}
inline std::string* Operation::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:chatservice.Operation.leader)
  return _s;
}
inline const std::string& Operation::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void Operation::_internal_set_leader(const std::string& value) {
  
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_leader() {
  
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_leader() {
  // @@protoc_insertion_point(field_release:chatservice.Operation.leader)
  return _impl_.leader_.Release();
}
inline void Operation::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    
  } else {
    
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Operation.leader)
}

// string clockVal = 8;
inline void Operation::clear_clockval() {
  _impl_.clockval_.ClearToEmpty();
}
inline const std::string& Operation::clockval() const {
  // @@protoc_insertion_point(field_get:chatservice.Operation.clockVal)
  return _internal_clockval();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_clockval(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clockval_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Operation.clockVal)
}
inline std::string* Operation::mutable_clockval() {
  std::string* _s = _internal_mutable_clockval();
  // @@protoc_insertion_point(field_mutable:chatservice.Operation.clockVal)
  return _s;
}
inline const std::string& Operation::_internal_clockval() const {
  return _impl_.clockval_.Get();
}
inline void Operation::_internal_set_clockval(const std::string& value) {
  
  _impl_.clockval_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_clockval() {
  
  return _impl_.clockval_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_clockval() {
  // @@protoc_insertion_point(field_release:chatservice.Operation.clockVal)
  return _impl_.clockval_.Release();
}
inline void Operation::set_allocated_clockval(std::string* clockval) {
  if (clockval != nullptr) {
    
  } else {
    
  }
  _impl_.clockval_.SetAllocated(clockval, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clockval_.IsDefault()) {
    _impl_.clockval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Operation.clockVal)
}

// -------------------------------------------------------------------

// AddToPendingResponse

// -------------------------------------------------------------------

// PendingLogRequest

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chatservice

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto
