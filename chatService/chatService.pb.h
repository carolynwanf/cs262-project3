// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chatService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chatService_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chatService_2eproto;
namespace chatService {
class chatMessage;
struct chatMessageDefaultTypeInternal;
extern chatMessageDefaultTypeInternal _chatMessage_default_instance_;
class createAccountMessage;
struct createAccountMessageDefaultTypeInternal;
extern createAccountMessageDefaultTypeInternal _createAccountMessage_default_instance_;
class createAccountReply;
struct createAccountReplyDefaultTypeInternal;
extern createAccountReplyDefaultTypeInternal _createAccountReply_default_instance_;
class deleteAccountMessage;
struct deleteAccountMessageDefaultTypeInternal;
extern deleteAccountMessageDefaultTypeInternal _deleteAccountMessage_default_instance_;
class deleteAccountReply;
struct deleteAccountReplyDefaultTypeInternal;
extern deleteAccountReplyDefaultTypeInternal _deleteAccountReply_default_instance_;
class loginMessage;
struct loginMessageDefaultTypeInternal;
extern loginMessageDefaultTypeInternal _loginMessage_default_instance_;
class loginReply;
struct loginReplyDefaultTypeInternal;
extern loginReplyDefaultTypeInternal _loginReply_default_instance_;
class logoutMessage;
struct logoutMessageDefaultTypeInternal;
extern logoutMessageDefaultTypeInternal _logoutMessage_default_instance_;
class logoutReply;
struct logoutReplyDefaultTypeInternal;
extern logoutReplyDefaultTypeInternal _logoutReply_default_instance_;
class messagesSeenMessage;
struct messagesSeenMessageDefaultTypeInternal;
extern messagesSeenMessageDefaultTypeInternal _messagesSeenMessage_default_instance_;
class newMessageReply;
struct newMessageReplyDefaultTypeInternal;
extern newMessageReplyDefaultTypeInternal _newMessageReply_default_instance_;
class notification;
struct notificationDefaultTypeInternal;
extern notificationDefaultTypeInternal _notification_default_instance_;
class queryMessagesMessage;
struct queryMessagesMessageDefaultTypeInternal;
extern queryMessagesMessageDefaultTypeInternal _queryMessagesMessage_default_instance_;
class queryNotificationsMessage;
struct queryNotificationsMessageDefaultTypeInternal;
extern queryNotificationsMessageDefaultTypeInternal _queryNotificationsMessage_default_instance_;
class queryUsersMessage;
struct queryUsersMessageDefaultTypeInternal;
extern queryUsersMessageDefaultTypeInternal _queryUsersMessage_default_instance_;
class sendMessageReply;
struct sendMessageReplyDefaultTypeInternal;
extern sendMessageReplyDefaultTypeInternal _sendMessageReply_default_instance_;
class user;
struct userDefaultTypeInternal;
extern userDefaultTypeInternal _user_default_instance_;
}  // namespace chatService
PROTOBUF_NAMESPACE_OPEN
template<> ::chatService::chatMessage* Arena::CreateMaybeMessage<::chatService::chatMessage>(Arena*);
template<> ::chatService::createAccountMessage* Arena::CreateMaybeMessage<::chatService::createAccountMessage>(Arena*);
template<> ::chatService::createAccountReply* Arena::CreateMaybeMessage<::chatService::createAccountReply>(Arena*);
template<> ::chatService::deleteAccountMessage* Arena::CreateMaybeMessage<::chatService::deleteAccountMessage>(Arena*);
template<> ::chatService::deleteAccountReply* Arena::CreateMaybeMessage<::chatService::deleteAccountReply>(Arena*);
template<> ::chatService::loginMessage* Arena::CreateMaybeMessage<::chatService::loginMessage>(Arena*);
template<> ::chatService::loginReply* Arena::CreateMaybeMessage<::chatService::loginReply>(Arena*);
template<> ::chatService::logoutMessage* Arena::CreateMaybeMessage<::chatService::logoutMessage>(Arena*);
template<> ::chatService::logoutReply* Arena::CreateMaybeMessage<::chatService::logoutReply>(Arena*);
template<> ::chatService::messagesSeenMessage* Arena::CreateMaybeMessage<::chatService::messagesSeenMessage>(Arena*);
template<> ::chatService::newMessageReply* Arena::CreateMaybeMessage<::chatService::newMessageReply>(Arena*);
template<> ::chatService::notification* Arena::CreateMaybeMessage<::chatService::notification>(Arena*);
template<> ::chatService::queryMessagesMessage* Arena::CreateMaybeMessage<::chatService::queryMessagesMessage>(Arena*);
template<> ::chatService::queryNotificationsMessage* Arena::CreateMaybeMessage<::chatService::queryNotificationsMessage>(Arena*);
template<> ::chatService::queryUsersMessage* Arena::CreateMaybeMessage<::chatService::queryUsersMessage>(Arena*);
template<> ::chatService::sendMessageReply* Arena::CreateMaybeMessage<::chatService::sendMessageReply>(Arena*);
template<> ::chatService::user* Arena::CreateMaybeMessage<::chatService::user>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chatService {

// ===================================================================

class createAccountMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.createAccountMessage) */ {
 public:
  inline createAccountMessage() : createAccountMessage(nullptr) {}
  ~createAccountMessage() override;
  explicit PROTOBUF_CONSTEXPR createAccountMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createAccountMessage(const createAccountMessage& from);
  createAccountMessage(createAccountMessage&& from) noexcept
    : createAccountMessage() {
    *this = ::std::move(from);
  }

  inline createAccountMessage& operator=(const createAccountMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline createAccountMessage& operator=(createAccountMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createAccountMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const createAccountMessage* internal_default_instance() {
    return reinterpret_cast<const createAccountMessage*>(
               &_createAccountMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(createAccountMessage& a, createAccountMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(createAccountMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createAccountMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createAccountMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createAccountMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createAccountMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createAccountMessage& from) {
    createAccountMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createAccountMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.createAccountMessage";
  }
  protected:
  explicit createAccountMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:chatService.createAccountMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class createAccountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.createAccountReply) */ {
 public:
  inline createAccountReply() : createAccountReply(nullptr) {}
  ~createAccountReply() override;
  explicit PROTOBUF_CONSTEXPR createAccountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createAccountReply(const createAccountReply& from);
  createAccountReply(createAccountReply&& from) noexcept
    : createAccountReply() {
    *this = ::std::move(from);
  }

  inline createAccountReply& operator=(const createAccountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline createAccountReply& operator=(createAccountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createAccountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const createAccountReply* internal_default_instance() {
    return reinterpret_cast<const createAccountReply*>(
               &_createAccountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(createAccountReply& a, createAccountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(createAccountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createAccountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createAccountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createAccountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createAccountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createAccountReply& from) {
    createAccountReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createAccountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.createAccountReply";
  }
  protected:
  explicit createAccountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kCreateAccountSuccessFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool createAccountSuccess = 1;
  void clear_createaccountsuccess();
  bool createaccountsuccess() const;
  void set_createaccountsuccess(bool value);
  private:
  bool _internal_createaccountsuccess() const;
  void _internal_set_createaccountsuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.createAccountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool createaccountsuccess_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class loginMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.loginMessage) */ {
 public:
  inline loginMessage() : loginMessage(nullptr) {}
  ~loginMessage() override;
  explicit PROTOBUF_CONSTEXPR loginMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  loginMessage(const loginMessage& from);
  loginMessage(loginMessage&& from) noexcept
    : loginMessage() {
    *this = ::std::move(from);
  }

  inline loginMessage& operator=(const loginMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline loginMessage& operator=(loginMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const loginMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const loginMessage* internal_default_instance() {
    return reinterpret_cast<const loginMessage*>(
               &_loginMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(loginMessage& a, loginMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(loginMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(loginMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  loginMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<loginMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const loginMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const loginMessage& from) {
    loginMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(loginMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.loginMessage";
  }
  protected:
  explicit loginMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:chatService.loginMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class loginReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.loginReply) */ {
 public:
  inline loginReply() : loginReply(nullptr) {}
  ~loginReply() override;
  explicit PROTOBUF_CONSTEXPR loginReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  loginReply(const loginReply& from);
  loginReply(loginReply&& from) noexcept
    : loginReply() {
    *this = ::std::move(from);
  }

  inline loginReply& operator=(const loginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline loginReply& operator=(loginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const loginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const loginReply* internal_default_instance() {
    return reinterpret_cast<const loginReply*>(
               &_loginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(loginReply& a, loginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(loginReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(loginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  loginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<loginReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const loginReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const loginReply& from) {
    loginReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(loginReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.loginReply";
  }
  protected:
  explicit loginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kLoginSuccessFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool loginSuccess = 1;
  void clear_loginsuccess();
  bool loginsuccess() const;
  void set_loginsuccess(bool value);
  private:
  bool _internal_loginsuccess() const;
  void _internal_set_loginsuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.loginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool loginsuccess_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class logoutMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.logoutMessage) */ {
 public:
  inline logoutMessage() : logoutMessage(nullptr) {}
  ~logoutMessage() override;
  explicit PROTOBUF_CONSTEXPR logoutMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  logoutMessage(const logoutMessage& from);
  logoutMessage(logoutMessage&& from) noexcept
    : logoutMessage() {
    *this = ::std::move(from);
  }

  inline logoutMessage& operator=(const logoutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline logoutMessage& operator=(logoutMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const logoutMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const logoutMessage* internal_default_instance() {
    return reinterpret_cast<const logoutMessage*>(
               &_logoutMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(logoutMessage& a, logoutMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(logoutMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(logoutMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  logoutMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<logoutMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const logoutMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const logoutMessage& from) {
    logoutMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(logoutMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.logoutMessage";
  }
  protected:
  explicit logoutMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoggingOutFieldNumber = 1,
  };
  // bool loggingOut = 1;
  void clear_loggingout();
  bool loggingout() const;
  void set_loggingout(bool value);
  private:
  bool _internal_loggingout() const;
  void _internal_set_loggingout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.logoutMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool loggingout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class logoutReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.logoutReply) */ {
 public:
  inline logoutReply() : logoutReply(nullptr) {}
  ~logoutReply() override;
  explicit PROTOBUF_CONSTEXPR logoutReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  logoutReply(const logoutReply& from);
  logoutReply(logoutReply&& from) noexcept
    : logoutReply() {
    *this = ::std::move(from);
  }

  inline logoutReply& operator=(const logoutReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline logoutReply& operator=(logoutReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const logoutReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const logoutReply* internal_default_instance() {
    return reinterpret_cast<const logoutReply*>(
               &_logoutReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(logoutReply& a, logoutReply& b) {
    a.Swap(&b);
  }
  inline void Swap(logoutReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(logoutReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  logoutReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<logoutReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const logoutReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const logoutReply& from) {
    logoutReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(logoutReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.logoutReply";
  }
  protected:
  explicit logoutReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kLoggedOutFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool loggedOut = 1;
  void clear_loggedout();
  bool loggedout() const;
  void set_loggedout(bool value);
  private:
  bool _internal_loggedout() const;
  void _internal_set_loggedout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.logoutReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool loggedout_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class queryUsersMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.queryUsersMessage) */ {
 public:
  inline queryUsersMessage() : queryUsersMessage(nullptr) {}
  ~queryUsersMessage() override;
  explicit PROTOBUF_CONSTEXPR queryUsersMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  queryUsersMessage(const queryUsersMessage& from);
  queryUsersMessage(queryUsersMessage&& from) noexcept
    : queryUsersMessage() {
    *this = ::std::move(from);
  }

  inline queryUsersMessage& operator=(const queryUsersMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline queryUsersMessage& operator=(queryUsersMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const queryUsersMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const queryUsersMessage* internal_default_instance() {
    return reinterpret_cast<const queryUsersMessage*>(
               &_queryUsersMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(queryUsersMessage& a, queryUsersMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(queryUsersMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(queryUsersMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  queryUsersMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<queryUsersMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const queryUsersMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const queryUsersMessage& from) {
    queryUsersMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(queryUsersMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.queryUsersMessage";
  }
  protected:
  explicit queryUsersMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chatService.queryUsersMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class user final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.user) */ {
 public:
  inline user() : user(nullptr) {}
  ~user() override;
  explicit PROTOBUF_CONSTEXPR user(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  user(const user& from);
  user(user&& from) noexcept
    : user() {
    *this = ::std::move(from);
  }

  inline user& operator=(const user& from) {
    CopyFrom(from);
    return *this;
  }
  inline user& operator=(user&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const user& default_instance() {
    return *internal_default_instance();
  }
  static inline const user* internal_default_instance() {
    return reinterpret_cast<const user*>(
               &_user_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(user& a, user& b) {
    a.Swap(&b);
  }
  inline void Swap(user* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(user* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  user* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<user>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const user& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const user& from) {
    user::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(user* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.user";
  }
  protected:
  explicit user(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chatService.user)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class sendMessageReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.sendMessageReply) */ {
 public:
  inline sendMessageReply() : sendMessageReply(nullptr) {}
  ~sendMessageReply() override;
  explicit PROTOBUF_CONSTEXPR sendMessageReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sendMessageReply(const sendMessageReply& from);
  sendMessageReply(sendMessageReply&& from) noexcept
    : sendMessageReply() {
    *this = ::std::move(from);
  }

  inline sendMessageReply& operator=(const sendMessageReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline sendMessageReply& operator=(sendMessageReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const sendMessageReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const sendMessageReply* internal_default_instance() {
    return reinterpret_cast<const sendMessageReply*>(
               &_sendMessageReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(sendMessageReply& a, sendMessageReply& b) {
    a.Swap(&b);
  }
  inline void Swap(sendMessageReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sendMessageReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sendMessageReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sendMessageReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const sendMessageReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const sendMessageReply& from) {
    sendMessageReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sendMessageReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.sendMessageReply";
  }
  protected:
  explicit sendMessageReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kMessageSentFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool messageSent = 1;
  void clear_messagesent();
  bool messagesent() const;
  void set_messagesent(bool value);
  private:
  bool _internal_messagesent() const;
  void _internal_set_messagesent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.sendMessageReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool messagesent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class queryNotificationsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.queryNotificationsMessage) */ {
 public:
  inline queryNotificationsMessage() : queryNotificationsMessage(nullptr) {}
  ~queryNotificationsMessage() override;
  explicit PROTOBUF_CONSTEXPR queryNotificationsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  queryNotificationsMessage(const queryNotificationsMessage& from);
  queryNotificationsMessage(queryNotificationsMessage&& from) noexcept
    : queryNotificationsMessage() {
    *this = ::std::move(from);
  }

  inline queryNotificationsMessage& operator=(const queryNotificationsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline queryNotificationsMessage& operator=(queryNotificationsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const queryNotificationsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const queryNotificationsMessage* internal_default_instance() {
    return reinterpret_cast<const queryNotificationsMessage*>(
               &_queryNotificationsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(queryNotificationsMessage& a, queryNotificationsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(queryNotificationsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(queryNotificationsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  queryNotificationsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<queryNotificationsMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const queryNotificationsMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const queryNotificationsMessage& from) {
    queryNotificationsMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(queryNotificationsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.queryNotificationsMessage";
  }
  protected:
  explicit queryNotificationsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryingNotificationsFieldNumber = 1,
  };
  // bool queryingNotifications = 1;
  void clear_queryingnotifications();
  bool queryingnotifications() const;
  void set_queryingnotifications(bool value);
  private:
  bool _internal_queryingnotifications() const;
  void _internal_set_queryingnotifications(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.queryNotificationsMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool queryingnotifications_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.notification) */ {
 public:
  inline notification() : notification(nullptr) {}
  ~notification() override;
  explicit PROTOBUF_CONSTEXPR notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  notification(const notification& from);
  notification(notification&& from) noexcept
    : notification() {
    *this = ::std::move(from);
  }

  inline notification& operator=(const notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline notification& operator=(notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const notification* internal_default_instance() {
    return reinterpret_cast<const notification*>(
               &_notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(notification& a, notification& b) {
    a.Swap(&b);
  }
  inline void Swap(notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const notification& from) {
    notification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.notification";
  }
  protected:
  explicit notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kNumberOfNotificationsFieldNumber = 2,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // int32 numberOfNotifications = 2;
  void clear_numberofnotifications();
  int32_t numberofnotifications() const;
  void set_numberofnotifications(int32_t value);
  private:
  int32_t _internal_numberofnotifications() const;
  void _internal_set_numberofnotifications(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.notification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    int32_t numberofnotifications_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class queryMessagesMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.queryMessagesMessage) */ {
 public:
  inline queryMessagesMessage() : queryMessagesMessage(nullptr) {}
  ~queryMessagesMessage() override;
  explicit PROTOBUF_CONSTEXPR queryMessagesMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  queryMessagesMessage(const queryMessagesMessage& from);
  queryMessagesMessage(queryMessagesMessage&& from) noexcept
    : queryMessagesMessage() {
    *this = ::std::move(from);
  }

  inline queryMessagesMessage& operator=(const queryMessagesMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline queryMessagesMessage& operator=(queryMessagesMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const queryMessagesMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const queryMessagesMessage* internal_default_instance() {
    return reinterpret_cast<const queryMessagesMessage*>(
               &_queryMessagesMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(queryMessagesMessage& a, queryMessagesMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(queryMessagesMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(queryMessagesMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  queryMessagesMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<queryMessagesMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const queryMessagesMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const queryMessagesMessage& from) {
    queryMessagesMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(queryMessagesMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.queryMessagesMessage";
  }
  protected:
  explicit queryMessagesMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chatService.queryMessagesMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class chatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.chatMessage) */ {
 public:
  inline chatMessage() : chatMessage(nullptr) {}
  ~chatMessage() override;
  explicit PROTOBUF_CONSTEXPR chatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  chatMessage(const chatMessage& from);
  chatMessage(chatMessage&& from) noexcept
    : chatMessage() {
    *this = ::std::move(from);
  }

  inline chatMessage& operator=(const chatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline chatMessage& operator=(chatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const chatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const chatMessage* internal_default_instance() {
    return reinterpret_cast<const chatMessage*>(
               &_chatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(chatMessage& a, chatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(chatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(chatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  chatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<chatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const chatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const chatMessage& from) {
    chatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(chatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.chatMessage";
  }
  protected:
  explicit chatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderUsernameFieldNumber = 1,
    kMsgContentFieldNumber = 2,
  };
  // string senderUsername = 1;
  void clear_senderusername();
  const std::string& senderusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senderusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senderusername();
  PROTOBUF_NODISCARD std::string* release_senderusername();
  void set_allocated_senderusername(std::string* senderusername);
  private:
  const std::string& _internal_senderusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senderusername(const std::string& value);
  std::string* _internal_mutable_senderusername();
  public:

  // string msgContent = 2;
  void clear_msgcontent();
  const std::string& msgcontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msgcontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msgcontent();
  PROTOBUF_NODISCARD std::string* release_msgcontent();
  void set_allocated_msgcontent(std::string* msgcontent);
  private:
  const std::string& _internal_msgcontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgcontent(const std::string& value);
  std::string* _internal_mutable_msgcontent();
  public:

  // @@protoc_insertion_point(class_scope:chatService.chatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senderusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgcontent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class deleteAccountMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.deleteAccountMessage) */ {
 public:
  inline deleteAccountMessage() : deleteAccountMessage(nullptr) {}
  ~deleteAccountMessage() override;
  explicit PROTOBUF_CONSTEXPR deleteAccountMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteAccountMessage(const deleteAccountMessage& from);
  deleteAccountMessage(deleteAccountMessage&& from) noexcept
    : deleteAccountMessage() {
    *this = ::std::move(from);
  }

  inline deleteAccountMessage& operator=(const deleteAccountMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteAccountMessage& operator=(deleteAccountMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteAccountMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteAccountMessage* internal_default_instance() {
    return reinterpret_cast<const deleteAccountMessage*>(
               &_deleteAccountMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(deleteAccountMessage& a, deleteAccountMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteAccountMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteAccountMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteAccountMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteAccountMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteAccountMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const deleteAccountMessage& from) {
    deleteAccountMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteAccountMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.deleteAccountMessage";
  }
  protected:
  explicit deleteAccountMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeletingAccountFieldNumber = 1,
  };
  // bool deletingAccount = 1;
  void clear_deletingaccount();
  bool deletingaccount() const;
  void set_deletingaccount(bool value);
  private:
  bool _internal_deletingaccount() const;
  void _internal_set_deletingaccount(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.deleteAccountMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool deletingaccount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class deleteAccountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.deleteAccountReply) */ {
 public:
  inline deleteAccountReply() : deleteAccountReply(nullptr) {}
  ~deleteAccountReply() override;
  explicit PROTOBUF_CONSTEXPR deleteAccountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteAccountReply(const deleteAccountReply& from);
  deleteAccountReply(deleteAccountReply&& from) noexcept
    : deleteAccountReply() {
    *this = ::std::move(from);
  }

  inline deleteAccountReply& operator=(const deleteAccountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteAccountReply& operator=(deleteAccountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteAccountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteAccountReply* internal_default_instance() {
    return reinterpret_cast<const deleteAccountReply*>(
               &_deleteAccountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(deleteAccountReply& a, deleteAccountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteAccountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteAccountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteAccountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteAccountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteAccountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const deleteAccountReply& from) {
    deleteAccountReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteAccountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.deleteAccountReply";
  }
  protected:
  explicit deleteAccountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kDeletedAccountFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool deletedAccount = 1;
  void clear_deletedaccount();
  bool deletedaccount() const;
  void set_deletedaccount(bool value);
  private:
  bool _internal_deletedaccount() const;
  void _internal_set_deletedaccount(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.deleteAccountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool deletedaccount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class messagesSeenMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.messagesSeenMessage) */ {
 public:
  inline messagesSeenMessage() : messagesSeenMessage(nullptr) {}
  ~messagesSeenMessage() override;
  explicit PROTOBUF_CONSTEXPR messagesSeenMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  messagesSeenMessage(const messagesSeenMessage& from);
  messagesSeenMessage(messagesSeenMessage&& from) noexcept
    : messagesSeenMessage() {
    *this = ::std::move(from);
  }

  inline messagesSeenMessage& operator=(const messagesSeenMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline messagesSeenMessage& operator=(messagesSeenMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const messagesSeenMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const messagesSeenMessage* internal_default_instance() {
    return reinterpret_cast<const messagesSeenMessage*>(
               &_messagesSeenMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(messagesSeenMessage& a, messagesSeenMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(messagesSeenMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(messagesSeenMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  messagesSeenMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<messagesSeenMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const messagesSeenMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const messagesSeenMessage& from) {
    messagesSeenMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(messagesSeenMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.messagesSeenMessage";
  }
  protected:
  explicit messagesSeenMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesSeenFieldNumber = 1,
    kFirstMessageIdxFieldNumber = 2,
  };
  // int32 messagesSeen = 1;
  void clear_messagesseen();
  int32_t messagesseen() const;
  void set_messagesseen(int32_t value);
  private:
  int32_t _internal_messagesseen() const;
  void _internal_set_messagesseen(int32_t value);
  public:

  // int32 firstMessageIdx = 2;
  void clear_firstmessageidx();
  int32_t firstmessageidx() const;
  void set_firstmessageidx(int32_t value);
  private:
  int32_t _internal_firstmessageidx() const;
  void _internal_set_firstmessageidx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.messagesSeenMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t messagesseen_;
    int32_t firstmessageidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class newMessageReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatService.newMessageReply) */ {
 public:
  inline newMessageReply() : newMessageReply(nullptr) {}
  ~newMessageReply() override;
  explicit PROTOBUF_CONSTEXPR newMessageReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  newMessageReply(const newMessageReply& from);
  newMessageReply(newMessageReply&& from) noexcept
    : newMessageReply() {
    *this = ::std::move(from);
  }

  inline newMessageReply& operator=(const newMessageReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline newMessageReply& operator=(newMessageReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const newMessageReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const newMessageReply* internal_default_instance() {
    return reinterpret_cast<const newMessageReply*>(
               &_newMessageReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(newMessageReply& a, newMessageReply& b) {
    a.Swap(&b);
  }
  inline void Swap(newMessageReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(newMessageReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  newMessageReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<newMessageReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const newMessageReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const newMessageReply& from) {
    newMessageReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(newMessageReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatService.newMessageReply";
  }
  protected:
  explicit newMessageReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceivedFieldNumber = 1,
  };
  // bool received = 1;
  void clear_received();
  bool received() const;
  void set_received(bool value);
  private:
  bool _internal_received() const;
  void _internal_set_received(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatService.newMessageReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool received_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// createAccountMessage

// string username = 1;
inline void createAccountMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& createAccountMessage::username() const {
  // @@protoc_insertion_point(field_get:chatService.createAccountMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void createAccountMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.createAccountMessage.username)
}
inline std::string* createAccountMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatService.createAccountMessage.username)
  return _s;
}
inline const std::string& createAccountMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void createAccountMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* createAccountMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* createAccountMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatService.createAccountMessage.username)
  return _impl_.username_.Release();
}
inline void createAccountMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.createAccountMessage.username)
}

// string password = 2;
inline void createAccountMessage::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& createAccountMessage::password() const {
  // @@protoc_insertion_point(field_get:chatService.createAccountMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void createAccountMessage::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.createAccountMessage.password)
}
inline std::string* createAccountMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatService.createAccountMessage.password)
  return _s;
}
inline const std::string& createAccountMessage::_internal_password() const {
  return _impl_.password_.Get();
}
inline void createAccountMessage::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* createAccountMessage::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* createAccountMessage::release_password() {
  // @@protoc_insertion_point(field_release:chatService.createAccountMessage.password)
  return _impl_.password_.Release();
}
inline void createAccountMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.createAccountMessage.password)
}

// -------------------------------------------------------------------

// createAccountReply

// bool createAccountSuccess = 1;
inline void createAccountReply::clear_createaccountsuccess() {
  _impl_.createaccountsuccess_ = false;
}
inline bool createAccountReply::_internal_createaccountsuccess() const {
  return _impl_.createaccountsuccess_;
}
inline bool createAccountReply::createaccountsuccess() const {
  // @@protoc_insertion_point(field_get:chatService.createAccountReply.createAccountSuccess)
  return _internal_createaccountsuccess();
}
inline void createAccountReply::_internal_set_createaccountsuccess(bool value) {
  
  _impl_.createaccountsuccess_ = value;
}
inline void createAccountReply::set_createaccountsuccess(bool value) {
  _internal_set_createaccountsuccess(value);
  // @@protoc_insertion_point(field_set:chatService.createAccountReply.createAccountSuccess)
}

// optional string errorMsg = 2;
inline bool createAccountReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool createAccountReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void createAccountReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& createAccountReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatService.createAccountReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void createAccountReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.createAccountReply.errorMsg)
}
inline std::string* createAccountReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatService.createAccountReply.errorMsg)
  return _s;
}
inline const std::string& createAccountReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void createAccountReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* createAccountReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* createAccountReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatService.createAccountReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void createAccountReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.createAccountReply.errorMsg)
}

// -------------------------------------------------------------------

// loginMessage

// string username = 1;
inline void loginMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& loginMessage::username() const {
  // @@protoc_insertion_point(field_get:chatService.loginMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void loginMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.loginMessage.username)
}
inline std::string* loginMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatService.loginMessage.username)
  return _s;
}
inline const std::string& loginMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void loginMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* loginMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* loginMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatService.loginMessage.username)
  return _impl_.username_.Release();
}
inline void loginMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.loginMessage.username)
}

// string password = 2;
inline void loginMessage::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& loginMessage::password() const {
  // @@protoc_insertion_point(field_get:chatService.loginMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void loginMessage::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.loginMessage.password)
}
inline std::string* loginMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatService.loginMessage.password)
  return _s;
}
inline const std::string& loginMessage::_internal_password() const {
  return _impl_.password_.Get();
}
inline void loginMessage::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* loginMessage::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* loginMessage::release_password() {
  // @@protoc_insertion_point(field_release:chatService.loginMessage.password)
  return _impl_.password_.Release();
}
inline void loginMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.loginMessage.password)
}

// -------------------------------------------------------------------

// loginReply

// bool loginSuccess = 1;
inline void loginReply::clear_loginsuccess() {
  _impl_.loginsuccess_ = false;
}
inline bool loginReply::_internal_loginsuccess() const {
  return _impl_.loginsuccess_;
}
inline bool loginReply::loginsuccess() const {
  // @@protoc_insertion_point(field_get:chatService.loginReply.loginSuccess)
  return _internal_loginsuccess();
}
inline void loginReply::_internal_set_loginsuccess(bool value) {
  
  _impl_.loginsuccess_ = value;
}
inline void loginReply::set_loginsuccess(bool value) {
  _internal_set_loginsuccess(value);
  // @@protoc_insertion_point(field_set:chatService.loginReply.loginSuccess)
}

// optional string errorMsg = 2;
inline bool loginReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool loginReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void loginReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& loginReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatService.loginReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void loginReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.loginReply.errorMsg)
}
inline std::string* loginReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatService.loginReply.errorMsg)
  return _s;
}
inline const std::string& loginReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void loginReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* loginReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* loginReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatService.loginReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void loginReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.loginReply.errorMsg)
}

// -------------------------------------------------------------------

// logoutMessage

// bool loggingOut = 1;
inline void logoutMessage::clear_loggingout() {
  _impl_.loggingout_ = false;
}
inline bool logoutMessage::_internal_loggingout() const {
  return _impl_.loggingout_;
}
inline bool logoutMessage::loggingout() const {
  // @@protoc_insertion_point(field_get:chatService.logoutMessage.loggingOut)
  return _internal_loggingout();
}
inline void logoutMessage::_internal_set_loggingout(bool value) {
  
  _impl_.loggingout_ = value;
}
inline void logoutMessage::set_loggingout(bool value) {
  _internal_set_loggingout(value);
  // @@protoc_insertion_point(field_set:chatService.logoutMessage.loggingOut)
}

// -------------------------------------------------------------------

// logoutReply

// bool loggedOut = 1;
inline void logoutReply::clear_loggedout() {
  _impl_.loggedout_ = false;
}
inline bool logoutReply::_internal_loggedout() const {
  return _impl_.loggedout_;
}
inline bool logoutReply::loggedout() const {
  // @@protoc_insertion_point(field_get:chatService.logoutReply.loggedOut)
  return _internal_loggedout();
}
inline void logoutReply::_internal_set_loggedout(bool value) {
  
  _impl_.loggedout_ = value;
}
inline void logoutReply::set_loggedout(bool value) {
  _internal_set_loggedout(value);
  // @@protoc_insertion_point(field_set:chatService.logoutReply.loggedOut)
}

// optional string errorMsg = 2;
inline bool logoutReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool logoutReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void logoutReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& logoutReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatService.logoutReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void logoutReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.logoutReply.errorMsg)
}
inline std::string* logoutReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatService.logoutReply.errorMsg)
  return _s;
}
inline const std::string& logoutReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void logoutReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* logoutReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* logoutReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatService.logoutReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void logoutReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.logoutReply.errorMsg)
}

// -------------------------------------------------------------------

// queryUsersMessage

// optional string username = 1;
inline bool queryUsersMessage::_internal_has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool queryUsersMessage::has_username() const {
  return _internal_has_username();
}
inline void queryUsersMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& queryUsersMessage::username() const {
  // @@protoc_insertion_point(field_get:chatService.queryUsersMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queryUsersMessage::set_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.queryUsersMessage.username)
}
inline std::string* queryUsersMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatService.queryUsersMessage.username)
  return _s;
}
inline const std::string& queryUsersMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void queryUsersMessage::_internal_set_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* queryUsersMessage::_internal_mutable_username() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* queryUsersMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatService.queryUsersMessage.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void queryUsersMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.queryUsersMessage.username)
}

// -------------------------------------------------------------------

// user

// string username = 1;
inline void user::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& user::username() const {
  // @@protoc_insertion_point(field_get:chatService.user.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void user::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.user.username)
}
inline std::string* user::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatService.user.username)
  return _s;
}
inline const std::string& user::_internal_username() const {
  return _impl_.username_.Get();
}
inline void user::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* user::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* user::release_username() {
  // @@protoc_insertion_point(field_release:chatService.user.username)
  return _impl_.username_.Release();
}
inline void user::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.user.username)
}

// -------------------------------------------------------------------

// sendMessageReply

// bool messageSent = 1;
inline void sendMessageReply::clear_messagesent() {
  _impl_.messagesent_ = false;
}
inline bool sendMessageReply::_internal_messagesent() const {
  return _impl_.messagesent_;
}
inline bool sendMessageReply::messagesent() const {
  // @@protoc_insertion_point(field_get:chatService.sendMessageReply.messageSent)
  return _internal_messagesent();
}
inline void sendMessageReply::_internal_set_messagesent(bool value) {
  
  _impl_.messagesent_ = value;
}
inline void sendMessageReply::set_messagesent(bool value) {
  _internal_set_messagesent(value);
  // @@protoc_insertion_point(field_set:chatService.sendMessageReply.messageSent)
}

// optional string errorMsg = 2;
inline bool sendMessageReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool sendMessageReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void sendMessageReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& sendMessageReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatService.sendMessageReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void sendMessageReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.sendMessageReply.errorMsg)
}
inline std::string* sendMessageReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatService.sendMessageReply.errorMsg)
  return _s;
}
inline const std::string& sendMessageReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void sendMessageReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* sendMessageReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* sendMessageReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatService.sendMessageReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void sendMessageReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.sendMessageReply.errorMsg)
}

// -------------------------------------------------------------------

// queryNotificationsMessage

// bool queryingNotifications = 1;
inline void queryNotificationsMessage::clear_queryingnotifications() {
  _impl_.queryingnotifications_ = false;
}
inline bool queryNotificationsMessage::_internal_queryingnotifications() const {
  return _impl_.queryingnotifications_;
}
inline bool queryNotificationsMessage::queryingnotifications() const {
  // @@protoc_insertion_point(field_get:chatService.queryNotificationsMessage.queryingNotifications)
  return _internal_queryingnotifications();
}
inline void queryNotificationsMessage::_internal_set_queryingnotifications(bool value) {
  
  _impl_.queryingnotifications_ = value;
}
inline void queryNotificationsMessage::set_queryingnotifications(bool value) {
  _internal_set_queryingnotifications(value);
  // @@protoc_insertion_point(field_set:chatService.queryNotificationsMessage.queryingNotifications)
}

// -------------------------------------------------------------------

// notification

// string user = 1;
inline void notification::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& notification::user() const {
  // @@protoc_insertion_point(field_get:chatService.notification.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void notification::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.notification.user)
}
inline std::string* notification::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:chatService.notification.user)
  return _s;
}
inline const std::string& notification::_internal_user() const {
  return _impl_.user_.Get();
}
inline void notification::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* notification::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* notification::release_user() {
  // @@protoc_insertion_point(field_release:chatService.notification.user)
  return _impl_.user_.Release();
}
inline void notification::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.notification.user)
}

// int32 numberOfNotifications = 2;
inline void notification::clear_numberofnotifications() {
  _impl_.numberofnotifications_ = 0;
}
inline int32_t notification::_internal_numberofnotifications() const {
  return _impl_.numberofnotifications_;
}
inline int32_t notification::numberofnotifications() const {
  // @@protoc_insertion_point(field_get:chatService.notification.numberOfNotifications)
  return _internal_numberofnotifications();
}
inline void notification::_internal_set_numberofnotifications(int32_t value) {
  
  _impl_.numberofnotifications_ = value;
}
inline void notification::set_numberofnotifications(int32_t value) {
  _internal_set_numberofnotifications(value);
  // @@protoc_insertion_point(field_set:chatService.notification.numberOfNotifications)
}

// -------------------------------------------------------------------

// queryMessagesMessage

// string username = 1;
inline void queryMessagesMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& queryMessagesMessage::username() const {
  // @@protoc_insertion_point(field_get:chatService.queryMessagesMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void queryMessagesMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.queryMessagesMessage.username)
}
inline std::string* queryMessagesMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatService.queryMessagesMessage.username)
  return _s;
}
inline const std::string& queryMessagesMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void queryMessagesMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* queryMessagesMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* queryMessagesMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatService.queryMessagesMessage.username)
  return _impl_.username_.Release();
}
inline void queryMessagesMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.queryMessagesMessage.username)
}

// -------------------------------------------------------------------

// chatMessage

// string senderUsername = 1;
inline void chatMessage::clear_senderusername() {
  _impl_.senderusername_.ClearToEmpty();
}
inline const std::string& chatMessage::senderusername() const {
  // @@protoc_insertion_point(field_get:chatService.chatMessage.senderUsername)
  return _internal_senderusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void chatMessage::set_senderusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.senderusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.chatMessage.senderUsername)
}
inline std::string* chatMessage::mutable_senderusername() {
  std::string* _s = _internal_mutable_senderusername();
  // @@protoc_insertion_point(field_mutable:chatService.chatMessage.senderUsername)
  return _s;
}
inline const std::string& chatMessage::_internal_senderusername() const {
  return _impl_.senderusername_.Get();
}
inline void chatMessage::_internal_set_senderusername(const std::string& value) {
  
  _impl_.senderusername_.Set(value, GetArenaForAllocation());
}
inline std::string* chatMessage::_internal_mutable_senderusername() {
  
  return _impl_.senderusername_.Mutable(GetArenaForAllocation());
}
inline std::string* chatMessage::release_senderusername() {
  // @@protoc_insertion_point(field_release:chatService.chatMessage.senderUsername)
  return _impl_.senderusername_.Release();
}
inline void chatMessage::set_allocated_senderusername(std::string* senderusername) {
  if (senderusername != nullptr) {
    
  } else {
    
  }
  _impl_.senderusername_.SetAllocated(senderusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.senderusername_.IsDefault()) {
    _impl_.senderusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.chatMessage.senderUsername)
}

// string msgContent = 2;
inline void chatMessage::clear_msgcontent() {
  _impl_.msgcontent_.ClearToEmpty();
}
inline const std::string& chatMessage::msgcontent() const {
  // @@protoc_insertion_point(field_get:chatService.chatMessage.msgContent)
  return _internal_msgcontent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void chatMessage::set_msgcontent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msgcontent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.chatMessage.msgContent)
}
inline std::string* chatMessage::mutable_msgcontent() {
  std::string* _s = _internal_mutable_msgcontent();
  // @@protoc_insertion_point(field_mutable:chatService.chatMessage.msgContent)
  return _s;
}
inline const std::string& chatMessage::_internal_msgcontent() const {
  return _impl_.msgcontent_.Get();
}
inline void chatMessage::_internal_set_msgcontent(const std::string& value) {
  
  _impl_.msgcontent_.Set(value, GetArenaForAllocation());
}
inline std::string* chatMessage::_internal_mutable_msgcontent() {
  
  return _impl_.msgcontent_.Mutable(GetArenaForAllocation());
}
inline std::string* chatMessage::release_msgcontent() {
  // @@protoc_insertion_point(field_release:chatService.chatMessage.msgContent)
  return _impl_.msgcontent_.Release();
}
inline void chatMessage::set_allocated_msgcontent(std::string* msgcontent) {
  if (msgcontent != nullptr) {
    
  } else {
    
  }
  _impl_.msgcontent_.SetAllocated(msgcontent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msgcontent_.IsDefault()) {
    _impl_.msgcontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.chatMessage.msgContent)
}

// -------------------------------------------------------------------

// deleteAccountMessage

// bool deletingAccount = 1;
inline void deleteAccountMessage::clear_deletingaccount() {
  _impl_.deletingaccount_ = false;
}
inline bool deleteAccountMessage::_internal_deletingaccount() const {
  return _impl_.deletingaccount_;
}
inline bool deleteAccountMessage::deletingaccount() const {
  // @@protoc_insertion_point(field_get:chatService.deleteAccountMessage.deletingAccount)
  return _internal_deletingaccount();
}
inline void deleteAccountMessage::_internal_set_deletingaccount(bool value) {
  
  _impl_.deletingaccount_ = value;
}
inline void deleteAccountMessage::set_deletingaccount(bool value) {
  _internal_set_deletingaccount(value);
  // @@protoc_insertion_point(field_set:chatService.deleteAccountMessage.deletingAccount)
}

// -------------------------------------------------------------------

// deleteAccountReply

// bool deletedAccount = 1;
inline void deleteAccountReply::clear_deletedaccount() {
  _impl_.deletedaccount_ = false;
}
inline bool deleteAccountReply::_internal_deletedaccount() const {
  return _impl_.deletedaccount_;
}
inline bool deleteAccountReply::deletedaccount() const {
  // @@protoc_insertion_point(field_get:chatService.deleteAccountReply.deletedAccount)
  return _internal_deletedaccount();
}
inline void deleteAccountReply::_internal_set_deletedaccount(bool value) {
  
  _impl_.deletedaccount_ = value;
}
inline void deleteAccountReply::set_deletedaccount(bool value) {
  _internal_set_deletedaccount(value);
  // @@protoc_insertion_point(field_set:chatService.deleteAccountReply.deletedAccount)
}

// optional string errorMsg = 2;
inline bool deleteAccountReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool deleteAccountReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void deleteAccountReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& deleteAccountReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatService.deleteAccountReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteAccountReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatService.deleteAccountReply.errorMsg)
}
inline std::string* deleteAccountReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatService.deleteAccountReply.errorMsg)
  return _s;
}
inline const std::string& deleteAccountReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void deleteAccountReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteAccountReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteAccountReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatService.deleteAccountReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void deleteAccountReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatService.deleteAccountReply.errorMsg)
}

// -------------------------------------------------------------------

// messagesSeenMessage

// int32 messagesSeen = 1;
inline void messagesSeenMessage::clear_messagesseen() {
  _impl_.messagesseen_ = 0;
}
inline int32_t messagesSeenMessage::_internal_messagesseen() const {
  return _impl_.messagesseen_;
}
inline int32_t messagesSeenMessage::messagesseen() const {
  // @@protoc_insertion_point(field_get:chatService.messagesSeenMessage.messagesSeen)
  return _internal_messagesseen();
}
inline void messagesSeenMessage::_internal_set_messagesseen(int32_t value) {
  
  _impl_.messagesseen_ = value;
}
inline void messagesSeenMessage::set_messagesseen(int32_t value) {
  _internal_set_messagesseen(value);
  // @@protoc_insertion_point(field_set:chatService.messagesSeenMessage.messagesSeen)
}

// int32 firstMessageIdx = 2;
inline void messagesSeenMessage::clear_firstmessageidx() {
  _impl_.firstmessageidx_ = 0;
}
inline int32_t messagesSeenMessage::_internal_firstmessageidx() const {
  return _impl_.firstmessageidx_;
}
inline int32_t messagesSeenMessage::firstmessageidx() const {
  // @@protoc_insertion_point(field_get:chatService.messagesSeenMessage.firstMessageIdx)
  return _internal_firstmessageidx();
}
inline void messagesSeenMessage::_internal_set_firstmessageidx(int32_t value) {
  
  _impl_.firstmessageidx_ = value;
}
inline void messagesSeenMessage::set_firstmessageidx(int32_t value) {
  _internal_set_firstmessageidx(value);
  // @@protoc_insertion_point(field_set:chatService.messagesSeenMessage.firstMessageIdx)
}

// -------------------------------------------------------------------

// newMessageReply

// bool received = 1;
inline void newMessageReply::clear_received() {
  _impl_.received_ = false;
}
inline bool newMessageReply::_internal_received() const {
  return _impl_.received_;
}
inline bool newMessageReply::received() const {
  // @@protoc_insertion_point(field_get:chatService.newMessageReply.received)
  return _internal_received();
}
inline void newMessageReply::_internal_set_received(bool value) {
  
  _impl_.received_ = value;
}
inline void newMessageReply::set_received(bool value) {
  _internal_set_received(value);
  // @@protoc_insertion_point(field_set:chatService.newMessageReply.received)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chatService

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto
